PragmaDirective
   Source: "pragma solidity ^0.4.18;"
ContractDefinition "strings"
   Source: "library strings {\n    struct slice {\n        uint _len;\n        uint _ptr;\n    }\n\n    function memcpy(uint dest, uint src, uint len) private {\n        // Copy word-length chunks while possible\n        for(; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        uint mask = 256 ** (32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    /*\n     * @dev Returns a slice containing the entire string.\n     * @param self The string to make a slice from.\n     * @return A newly allocated slice containing the entire string.\n     */\n    function toSlice(string self) internal returns (slice) {\n        uint ptr;\n        assembly {\n            ptr := add(self, 0x20)\n        }\n        return slice(bytes(self).length, ptr);\n    }\n\n    /*\n     * @dev Returns the length of a null-terminated bytes32 string.\n     * @param self The value to find the length of.\n     * @return The length of the string, from 0 to 32.\n     */\n    function len(bytes32 self) internal returns (uint) {\n        uint ret;\n        if (self == 0)\n            return 0;\n        if (self & 0xffffffffffffffffffffffffffffffff == 0) {\n            ret += 16;\n            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\n        }\n        if (self & 0xffffffffffffffff == 0) {\n            ret += 8;\n            self = bytes32(uint(self) / 0x10000000000000000);\n        }\n        if (self & 0xffffffff == 0) {\n            ret += 4;\n            self = bytes32(uint(self) / 0x100000000);\n        }\n        if (self & 0xffff == 0) {\n            ret += 2;\n            self = bytes32(uint(self) / 0x10000);\n        }\n        if (self & 0xff == 0) {\n            ret += 1;\n        }\n        return 32 - ret;\n    }\n\n    /*\n     * @dev Returns a slice containing the entire bytes32, interpreted as a\n     *      null-termintaed utf-8 string.\n     * @param self The bytes32 value to convert to a slice.\n     * @return A new slice containing the value of the input argument up to the\n     *         first null.\n     */\n    function toSliceB32(bytes32 self) internal returns (slice ret) {\n        // Allocate space for `self` in memory, copy it there, and point ret at it\n        assembly {\n            let ptr := mload(0x40)\n            mstore(0x40, add(ptr, 0x20))\n            mstore(ptr, self)\n            mstore(add(ret, 0x20), ptr)\n        }\n        ret._len = len(self);\n    }\n\n    /*\n     * @dev Returns a new slice containing the same data as the current slice.\n     * @param self The slice to copy.\n     * @return A new slice containing the same data as `self`.\n     */\n    function copy(slice self) internal returns (slice) {\n        return slice(self._len, self._ptr);\n    }\n\n    /*\n     * @dev Copies a slice to a new string.\n     * @param self The slice to copy.\n     * @return A newly allocated string containing the slice's text.\n     */\n    function toString(slice self) internal returns (string) {\n        var ret = new string(self._len);\n        uint retptr;\n        assembly { retptr := add(ret, 32) }\n\n        memcpy(retptr, self._ptr, self._len);\n        return ret;\n    }\n\n    /*\n     * @dev Returns the length in runes of the slice. Note that this operation\n     *      takes time proportional to the length of the slice; avoid using it\n     *      in loops, and call `slice.empty()` if you only need to know whether\n     *      the slice is empty or not.\n     * @param self The slice to operate on.\n     * @return The length of the slice in runes.\n     */\n    function len(slice self) internal returns (uint l) {\n        // Starting at ptr-31 means the LSB will be the byte we care about\n        var ptr = self._ptr - 31;\n        var end = ptr + self._len;\n        for (l = 0; ptr < end; l++) {\n            uint8 b;\n            assembly { b := and(mload(ptr), 0xFF) }\n            if (b < 0x80) {\n                ptr += 1;\n            } else if(b < 0xE0) {\n                ptr += 2;\n            } else if(b < 0xF0) {\n                ptr += 3;\n            } else if(b < 0xF8) {\n                ptr += 4;\n            } else if(b < 0xFC) {\n                ptr += 5;\n            } else {\n                ptr += 6;\n            }\n        }\n    }\n\n    /*\n     * @dev Returns true if the slice is empty (has a length of 0).\n     * @param self The slice to operate on.\n     * @return True if the slice is empty, False otherwise.\n     */\n    function empty(slice self) internal returns (bool) {\n        return self._len == 0;\n    }\n\n    /*\n     * @dev Returns a positive number if `other` comes lexicographically after\n     *      `self`, a negative number if it comes before, or zero if the\n     *      contents of the two slices are equal. Comparison is done per-rune,\n     *      on unicode codepoints.\n     * @param self The first slice to compare.\n     * @param other The second slice to compare.\n     * @return The result of the comparison.\n     */\n    function compare(slice self, slice other) internal returns (int) {\n        uint shortest = self._len;\n        if (other._len < self._len)\n            shortest = other._len;\n\n        var selfptr = self._ptr;\n        var otherptr = other._ptr;\n        for (uint idx = 0; idx < shortest; idx += 32) {\n            uint a;\n            uint b;\n            assembly {\n                a := mload(selfptr)\n                b := mload(otherptr)\n            }\n            if (a != b) {\n                // Mask out irrelevant bytes and check again\n                uint mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\n                var diff = (a & mask) - (b & mask);\n                if (diff != 0)\n                    return int(diff);\n            }\n            selfptr += 32;\n            otherptr += 32;\n        }\n        return int(self._len) - int(other._len);\n    }\n\n    /*\n     * @dev Returns true if the two slices contain the same text.\n     * @param self The first slice to compare.\n     * @param self The second slice to compare.\n     * @return True if the slices are equal, false otherwise.\n     */\n    function equals(slice self, slice other) internal returns (bool) {\n        return compare(self, other) == 0;\n    }\n\n    /*\n     * @dev Extracts the first rune in the slice into `rune`, advancing the\n     *      slice to point to the next rune and returning `self`.\n     * @param self The slice to operate on.\n     * @param rune The slice that will contain the first rune.\n     * @return `rune`.\n     */\n    function nextRune(slice self, slice rune) internal returns (slice) {\n        rune._ptr = self._ptr;\n\n        if (self._len == 0) {\n            rune._len = 0;\n            return rune;\n        }\n\n        uint len;\n        uint b;\n        // Load the first byte of the rune into the LSBs of b\n        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\n        if (b < 0x80) {\n            len = 1;\n        } else if(b < 0xE0) {\n            len = 2;\n        } else if(b < 0xF0) {\n            len = 3;\n        } else {\n            len = 4;\n        }\n\n        // Check for truncated codepoints\n        if (len > self._len) {\n            rune._len = self._len;\n            self._ptr += self._len;\n            self._len = 0;\n            return rune;\n        }\n\n        self._ptr += len;\n        self._len -= len;\n        rune._len = len;\n        return rune;\n    }\n\n    /*\n     * @dev Returns the first rune in the slice, advancing the slice to point\n     *      to the next rune.\n     * @param self The slice to operate on.\n     * @return A slice containing only the first rune from `self`.\n     */\n    function nextRune(slice self) internal returns (slice ret) {\n        nextRune(self, ret);\n    }\n\n    /*\n     * @dev Returns the number of the first codepoint in the slice.\n     * @param self The slice to operate on.\n     * @return The number of the first codepoint in the slice.\n     */\n    function ord(slice self) internal returns (uint ret) {\n        if (self._len == 0) {\n            return 0;\n        }\n\n        uint word;\n        uint length;\n        uint divisor = 2 ** 248;\n\n        // Load the rune into the MSBs of b\n        assembly { word:= mload(mload(add(self, 32))) }\n        var b = word / divisor;\n        if (b < 0x80) {\n            ret = b;\n            length = 1;\n        } else if(b < 0xE0) {\n            ret = b & 0x1F;\n            length = 2;\n        } else if(b < 0xF0) {\n            ret = b & 0x0F;\n            length = 3;\n        } else {\n            ret = b & 0x07;\n            length = 4;\n        }\n\n        // Check for truncated codepoints\n        if (length > self._len) {\n            return 0;\n        }\n\n        for (uint i = 1; i < length; i++) {\n            divisor = divisor / 256;\n            b = (word / divisor) & 0xFF;\n            if (b & 0xC0 != 0x80) {\n                // Invalid UTF-8 sequence\n                return 0;\n            }\n            ret = (ret * 64) | (b & 0x3F);\n        }\n\n        return ret;\n    }\n\n    /*\n     * @dev Returns the keccak-256 hash of the slice.\n     * @param self The slice to hash.\n     * @return The hash of the slice.\n     */\n    function keccak(slice self) internal returns (bytes32 ret) {\n        assembly {\n            ret := keccak256(mload(add(self, 32)), mload(self))\n        }\n    }\n\n    /*\n     * @dev Returns true if `self` starts with `needle`.\n     * @param self The slice to operate on.\n     * @param needle The slice to search for.\n     * @return True if the slice starts with the provided text, false otherwise.\n     */\n    function startsWith(slice self, slice needle) internal returns (bool) {\n        if (self._len < needle._len) {\n            return false;\n        }\n\n        if (self._ptr == needle._ptr) {\n            return true;\n        }\n\n        bool equal;\n        assembly {\n            let length := mload(needle)\n            let selfptr := mload(add(self, 0x20))\n            let needleptr := mload(add(needle, 0x20))\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n        }\n        return equal;\n    }\n\n    /*\n     * @dev If `self` starts with `needle`, `needle` is removed from the\n     *      beginning of `self`. Otherwise, `self` is unmodified.\n     * @param self The slice to operate on.\n     * @param needle The slice to search for.\n     * @return `self`\n     */\n    function beyond(slice self, slice needle) internal returns (slice) {\n        if (self._len < needle._len) {\n            return self;\n        }\n\n        bool equal = true;\n        if (self._ptr != needle._ptr) {\n            assembly {\n                let length := mload(needle)\n                let selfptr := mload(add(self, 0x20))\n                let needleptr := mload(add(needle, 0x20))\n                equal := eq(sha3(selfptr, length), sha3(needleptr, length))\n            }\n        }\n\n        if (equal) {\n            self._len -= needle._len;\n            self._ptr += needle._len;\n        }\n\n        return self;\n    }\n\n    /*\n     * @dev Returns true if the slice ends with `needle`.\n     * @param self The slice to operate on.\n     * @param needle The slice to search for.\n     * @return True if the slice starts with the provided text, false otherwise.\n     */\n    function endsWith(slice self, slice needle) internal returns (bool) {\n        if (self._len < needle._len) {\n            return false;\n        }\n\n        var selfptr = self._ptr + self._len - needle._len;\n\n        if (selfptr == needle._ptr) {\n            return true;\n        }\n\n        bool equal;\n        assembly {\n            let length := mload(needle)\n            let needleptr := mload(add(needle, 0x20))\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n        }\n\n        return equal;\n    }\n\n    /*\n     * @dev If `self` ends with `needle`, `needle` is removed from the\n     *      end of `self`. Otherwise, `self` is unmodified.\n     * @param self The slice to operate on.\n     * @param needle The slice to search for.\n     * @return `self`\n     */\n    function until(slice self, slice needle) internal returns (slice) {\n        if (self._len < needle._len) {\n            return self;\n        }\n\n        var selfptr = self._ptr + self._len - needle._len;\n        bool equal = true;\n        if (selfptr != needle._ptr) {\n            assembly {\n                let length := mload(needle)\n                let needleptr := mload(add(needle, 0x20))\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n            }\n        }\n\n        if (equal) {\n            self._len -= needle._len;\n        }\n\n        return self;\n    }\n\n    // Returns the memory address of the first byte of the first occurrence of\n    // `needle` in `self`, or the first byte after `self` if not found.\n    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private returns (uint) {\n        uint ptr;\n        uint idx;\n\n        if (needlelen <= selflen) {\n            if (needlelen <= 32) {\n                // Optimized assembly for 68 gas per byte on short strings\n                assembly {\n                    let mask := not(sub(exp(2, mul(8, sub(32, needlelen))), 1))\n                    let needledata := and(mload(needleptr), mask)\n                    let end := add(selfptr, sub(selflen, needlelen))\n                    ptr := selfptr\n                    loop:\n                    jumpi(exit, eq(and(mload(ptr), mask), needledata))\n                    ptr := add(ptr, 1)\n                    jumpi(loop, lt(sub(ptr, 1), end))\n                    ptr := add(selfptr, selflen)\n                    exit:\n                }\n                return ptr;\n            } else {\n                // For long needles, use hashing\n                bytes32 hash;\n                assembly { hash := sha3(needleptr, needlelen) }\n                ptr = selfptr;\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\n                    bytes32 testHash;\n                    assembly { testHash := sha3(ptr, needlelen) }\n                    if (hash == testHash)\n                        return ptr;\n                    ptr += 1;\n                }\n            }\n        }\n        return selfptr + selflen;\n    }\n\n    // Returns the memory address of the first byte after the last occurrence of\n    // `needle` in `self`, or the address of `self` if not found.\n    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private returns (uint) {\n        uint ptr;\n\n        if (needlelen <= selflen) {\n            if (needlelen <= 32) {\n                // Optimized assembly for 69 gas per byte on short strings\n                assembly {\n                    let mask := not(sub(exp(2, mul(8, sub(32, needlelen))), 1))\n                    let needledata := and(mload(needleptr), mask)\n                    ptr := add(selfptr, sub(selflen, needlelen))\n                    loop:\n                    jumpi(ret, eq(and(mload(ptr), mask), needledata))\n                    ptr := sub(ptr, 1)\n                    jumpi(loop, gt(add(ptr, 1), selfptr))\n                    ptr := selfptr\n                    jump(exit)\n                    ret:\n                    ptr := add(ptr, needlelen)\n                    exit:\n                }\n                return ptr;\n            } else {\n                // For long needles, use hashing\n                bytes32 hash;\n                assembly { hash := sha3(needleptr, needlelen) }\n                ptr = selfptr + (selflen - needlelen);\n                while (ptr >= selfptr) {\n                    bytes32 testHash;\n                    assembly { testHash := sha3(ptr, needlelen) }\n                    if (hash == testHash)\n                        return ptr + needlelen;\n                    ptr -= 1;\n                }\n            }\n        }\n        return selfptr;\n    }\n\n    /*\n     * @dev Modifies `self` to contain everything from the first occurrence of\n     *      `needle` to the end of the slice. `self` is set to the empty slice\n     *      if `needle` is not found.\n     * @param self The slice to search and modify.\n     * @param needle The text to search for.\n     * @return `self`.\n     */\n    function find(slice self, slice needle) internal returns (slice) {\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n        self._len -= ptr - self._ptr;\n        self._ptr = ptr;\n        return self;\n    }\n\n    /*\n     * @dev Modifies `self` to contain the part of the string from the start of\n     *      `self` to the end of the first occurrence of `needle`. If `needle`\n     *      is not found, `self` is set to the empty slice.\n     * @param self The slice to search and modify.\n     * @param needle The text to search for.\n     * @return `self`.\n     */\n    function rfind(slice self, slice needle) internal returns (slice) {\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n        self._len = ptr - self._ptr;\n        return self;\n    }\n\n    /*\n     * @dev Splits the slice, setting `self` to everything after the first\n     *      occurrence of `needle`, and `token` to everything before it. If\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n     *      and `token` is set to the entirety of `self`.\n     * @param self The slice to split.\n     * @param needle The text to search for in `self`.\n     * @param token An output parameter to which the first token is written.\n     * @return `token`.\n     */\n    function split(slice self, slice needle, slice token) internal returns (slice) {\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n        token._ptr = self._ptr;\n        token._len = ptr - self._ptr;\n        if (ptr == self._ptr + self._len) {\n            // Not found\n            self._len = 0;\n        } else {\n            self._len -= token._len + needle._len;\n            self._ptr = ptr + needle._len;\n        }\n        return token;\n    }\n\n    /*\n     * @dev Splits the slice, setting `self` to everything after the first\n     *      occurrence of `needle`, and returning everything before it. If\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n     *      and the entirety of `self` is returned.\n     * @param self The slice to split.\n     * @param needle The text to search for in `self`.\n     * @return The part of `self` up to the first occurrence of `delim`.\n     */\n    function split(slice self, slice needle) internal returns (slice token) {\n        split(self, needle, token);\n    }\n\n    /*\n     * @dev Splits the slice, setting `self` to everything before the last\n     *      occurrence of `needle`, and `token` to everything after it. If\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n     *      and `token` is set to the entirety of `self`.\n     * @param self The slice to split.\n     * @param needle The text to search for in `self`.\n     * @param token An output parameter to which the first token is written.\n     * @return `token`.\n     */\n    function rsplit(slice self, slice needle, slice token) internal returns (slice) {\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n        token._ptr = ptr;\n        token._len = self._len - (ptr - self._ptr);\n        if (ptr == self._ptr) {\n            // Not found\n            self._len = 0;\n        } else {\n            self._len -= token._len + needle._len;\n        }\n        return token;\n    }\n\n    /*\n     * @dev Splits the slice, setting `self` to everything before the last\n     *      occurrence of `needle`, and returning everything after it. If\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\n     *      and the entirety of `self` is returned.\n     * @param self The slice to split.\n     * @param needle The text to search for in `self`.\n     * @return The part of `self` after the last occurrence of `delim`.\n     */\n    function rsplit(slice self, slice needle) internal returns (slice token) {\n        rsplit(self, needle, token);\n    }\n\n    /*\n     * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.\n     * @param self The slice to search.\n     * @param needle The text to search for in `self`.\n     * @return The number of occurrences of `needle` found in `self`.\n     */\n    function count(slice self, slice needle) internal returns (uint cnt) {\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\n        while (ptr <= self._ptr + self._len) {\n            cnt++;\n            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\n        }\n    }\n\n    /*\n     * @dev Returns True if `self` contains `needle`.\n     * @param self The slice to search.\n     * @param needle The text to search for in `self`.\n     * @return True if `needle` is found in `self`, false otherwise.\n     */\n    function contains(slice self, slice needle) internal returns (bool) {\n        return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\n    }\n\n    /*\n     * @dev Returns a newly allocated string containing the concatenation of\n     *      `self` and `other`.\n     * @param self The first slice to concatenate.\n     * @param other The second slice to concatenate.\n     * @return The concatenation of the two strings.\n     */\n    function concat(slice self, slice other) internal returns (string) {\n        var ret = new string(self._len + other._len);\n        uint retptr;\n        assembly { retptr := add(ret, 32) }\n        memcpy(retptr, self._ptr, self._len);\n        memcpy(retptr + self._len, other._ptr, other._len);\n        return ret;\n    }\n\n    /*\n     * @dev Joins an array of slices, using `self` as a delimiter, returning a\n     *      newly allocated string.\n     * @param self The delimiter to use.\n     * @param parts A list of slices to join.\n     * @return A newly allocated string containing all the slices in `parts`,\n     *         joined with `self`.\n     */\n    function join(slice self, slice[] parts) internal returns (string) {\n        if (parts.length == 0)\n            return \"\";\n\n        uint length = self._len * (parts.length - 1);\n        for(uint i = 0; i < parts.length; i++)\n            length += parts[i]._len;\n\n        var ret = new string(length);\n        uint retptr;\n        assembly { retptr := add(ret, 32) }\n\n        for(i = 0; i < parts.length; i++) {\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);\n            retptr += parts[i]._len;\n            if (i < parts.length - 1) {\n                memcpy(retptr, self._ptr, self._len);\n                retptr += self._len;\n            }\n        }\n\n        return ret;\n    }\n}"
  StructDefinition "slice"
     Source: "struct slice {\n        uint _len;\n        uint _ptr;\n    }"
    VariableDeclaration "_len"
       Type: uint256
       Source: "uint _len"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "_ptr"
       Type: uint256
       Source: "uint _ptr"
      ElementaryTypeName uint
         Source: "uint"
  FunctionDefinition "memcpy"
     Source: "function memcpy(uint dest, uint src, uint len) private {\n        // Copy word-length chunks while possible\n        for(; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        uint mask = 256 ** (32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }"
    ParameterList
       Source: "(uint dest, uint src, uint len)"
      VariableDeclaration "dest"
         Type: uint256
         Source: "uint dest"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "src"
         Type: uint256
         Source: "uint src"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "len"
         Type: uint256
         Source: "uint len"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: ""
    Block
       Source: "{\n        // Copy word-length chunks while possible\n        for(; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        uint mask = 256 ** (32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }"
      ForStatement
         Source: "for(; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }"
        BinaryOperation using operator >=
           Type: bool
           Source: "len >= 32"
          Identifier len
             Type: uint256
             Source: "len"
          Literal, token: [no token] value: 32
             Type: int_const 32
             Source: "32"
        ExpressionStatement
           Source: "len -= 32"
          Assignment using operator -=
             Type: uint256
             Source: "len -= 32"
            Identifier len
               Type: uint256
               Source: "len"
            Literal, token: [no token] value: 32
               Type: int_const 32
               Source: "32"
        Block
           Source: "{\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }"
          InlineAssembly
             Source: "assembly {\n                mstore(dest, mload(src))\n            }\n            dest"
          ExpressionStatement
             Source: "dest += 32"
            Assignment using operator +=
               Type: uint256
               Source: "dest += 32"
              Identifier dest
                 Type: uint256
                 Source: "dest"
              Literal, token: [no token] value: 32
                 Type: int_const 32
                 Source: "32"
          ExpressionStatement
             Source: "src += 32"
            Assignment using operator +=
               Type: uint256
               Source: "src += 32"
              Identifier src
                 Type: uint256
                 Source: "src"
              Literal, token: [no token] value: 32
                 Type: int_const 32
                 Source: "32"
      VariableDeclarationStatement
         Source: "uint mask = 256 ** (32 - len) - 1"
        VariableDeclaration "mask"
           Type: uint256
           Source: "uint mask"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator -
           Type: uint256
           Source: "256 ** (32 - len) - 1"
          BinaryOperation using operator **
             Type: uint256
             Source: "256 ** (32 - len)"
            Literal, token: [no token] value: 256
               Type: int_const 256
               Source: "256"
            TupleExpression
               Type: uint256
               Source: "(32 - len)"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "32 - len"
                Literal, token: [no token] value: 32
                   Type: int_const 32
                   Source: "32"
                Identifier len
                   Type: uint256
                   Source: "len"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
      InlineAssembly
         Source: "assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }"
  FunctionDefinition "toSlice"
     Source: "function toSlice(string self) internal returns (slice) {\n        uint ptr;\n        assembly {\n            ptr := add(self, 0x20)\n        }\n        return slice(bytes(self).length, ptr);\n    }"
    ParameterList
       Source: "(string self)"
      VariableDeclaration "self"
         Type: string memory
         Source: "string self"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Source: "(slice)"
      VariableDeclaration ""
         Type: struct strings.slice memory
         Source: "slice"
        UserDefinedTypeName "slice"
           Source: "slice"
    Block
       Source: "{\n        uint ptr;\n        assembly {\n            ptr := add(self, 0x20)\n        }\n        return slice(bytes(self).length, ptr);\n    }"
      VariableDeclarationStatement
         Source: "uint ptr"
        VariableDeclaration "ptr"
           Type: uint256
           Source: "uint ptr"
          ElementaryTypeName uint
             Source: "uint"
      InlineAssembly
         Source: "assembly {\n            ptr := add(self, 0x20)\n        }\n        return"
      Return
         Source: "return slice(bytes(self).length, ptr)"
        FunctionCall
           Type: struct strings.slice memory
           Source: "slice(bytes(self).length, ptr)"
          Identifier slice
             Type: type(struct strings.slice storage pointer)
             Source: "slice"
          MemberAccess to member length
             Type: uint256
             Source: "bytes(self).length"
            FunctionCall
               Type: bytes memory
               Source: "bytes(self)"
              ElementaryTypeNameExpression bytes
                 Type: type(bytes storage pointer)
                 Source: "bytes"
              Identifier self
                 Type: string memory
                 Source: "self"
          Identifier ptr
             Type: uint256
             Source: "ptr"
  FunctionDefinition "len"
     Source: "function len(bytes32 self) internal returns (uint) {\n        uint ret;\n        if (self == 0)\n            return 0;\n        if (self & 0xffffffffffffffffffffffffffffffff == 0) {\n            ret += 16;\n            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\n        }\n        if (self & 0xffffffffffffffff == 0) {\n            ret += 8;\n            self = bytes32(uint(self) / 0x10000000000000000);\n        }\n        if (self & 0xffffffff == 0) {\n            ret += 4;\n            self = bytes32(uint(self) / 0x100000000);\n        }\n        if (self & 0xffff == 0) {\n            ret += 2;\n            self = bytes32(uint(self) / 0x10000);\n        }\n        if (self & 0xff == 0) {\n            ret += 1;\n        }\n        return 32 - ret;\n    }"
    ParameterList
       Source: "(bytes32 self)"
      VariableDeclaration "self"
         Type: bytes32
         Source: "bytes32 self"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\n        uint ret;\n        if (self == 0)\n            return 0;\n        if (self & 0xffffffffffffffffffffffffffffffff == 0) {\n            ret += 16;\n            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\n        }\n        if (self & 0xffffffffffffffff == 0) {\n            ret += 8;\n            self = bytes32(uint(self) / 0x10000000000000000);\n        }\n        if (self & 0xffffffff == 0) {\n            ret += 4;\n            self = bytes32(uint(self) / 0x100000000);\n        }\n        if (self & 0xffff == 0) {\n            ret += 2;\n            self = bytes32(uint(self) / 0x10000);\n        }\n        if (self & 0xff == 0) {\n            ret += 1;\n        }\n        return 32 - ret;\n    }"
      VariableDeclarationStatement
         Source: "uint ret"
        VariableDeclaration "ret"
           Type: uint256
           Source: "uint ret"
          ElementaryTypeName uint
             Source: "uint"
      IfStatement
         Source: "if (self == 0)\n            return 0"
        BinaryOperation using operator ==
           Type: bool
           Source: "self == 0"
          Identifier self
             Type: bytes32
             Source: "self"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Return
           Source: "return 0"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      IfStatement
         Source: "if (self & 0xffffffffffffffffffffffffffffffff == 0) {\n            ret += 16;\n            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\n        }"
        BinaryOperation using operator ==
           Type: bool
           Source: "self & 0xffffffffffffffffffffffffffffffff == 0"
          BinaryOperation using operator &
             Type: bytes32
             Source: "self & 0xffffffffffffffffffffffffffffffff"
            Identifier self
               Type: bytes32
               Source: "self"
            Literal, token: [no token] value: 0xffffffffffffffffffffffffffffffff
               Type: int_const 340282366920938463463374607431768211455
               Source: "0xffffffffffffffffffffffffffffffff"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\n            ret += 16;\n            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\n        }"
          ExpressionStatement
             Source: "ret += 16"
            Assignment using operator +=
               Type: uint256
               Source: "ret += 16"
              Identifier ret
                 Type: uint256
                 Source: "ret"
              Literal, token: [no token] value: 16
                 Type: int_const 16
                 Source: "16"
          ExpressionStatement
             Source: "self = bytes32(uint(self) / 0x100000000000000000000000000000000)"
            Assignment using operator =
               Type: bytes32
               Source: "self = bytes32(uint(self) / 0x100000000000000000000000000000000)"
              Identifier self
                 Type: bytes32
                 Source: "self"
              FunctionCall
                 Type: bytes32
                 Source: "bytes32(uint(self) / 0x100000000000000000000000000000000)"
                ElementaryTypeNameExpression bytes32
                   Type: type(bytes32)
                   Source: "bytes32"
                BinaryOperation using operator /
                   Type: uint256
                   Source: "uint(self) / 0x100000000000000000000000000000000"
                  FunctionCall
                     Type: uint256
                     Source: "uint(self)"
                    ElementaryTypeNameExpression uint
                       Type: type(uint256)
                       Source: "uint"
                    Identifier self
                       Type: bytes32
                       Source: "self"
                  Literal, token: [no token] value: 0x100000000000000000000000000000000
                     Type: int_const 340282366920938463463374607431768211456
                     Source: "0x100000000000000000000000000000000"
      IfStatement
         Source: "if (self & 0xffffffffffffffff == 0) {\n            ret += 8;\n            self = bytes32(uint(self) / 0x10000000000000000);\n        }"
        BinaryOperation using operator ==
           Type: bool
           Source: "self & 0xffffffffffffffff == 0"
          BinaryOperation using operator &
             Type: bytes32
             Source: "self & 0xffffffffffffffff"
            Identifier self
               Type: bytes32
               Source: "self"
            Literal, token: [no token] value: 0xffffffffffffffff
               Type: int_const 18446744073709551615
               Source: "0xffffffffffffffff"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\n            ret += 8;\n            self = bytes32(uint(self) / 0x10000000000000000);\n        }"
          ExpressionStatement
             Source: "ret += 8"
            Assignment using operator +=
               Type: uint256
               Source: "ret += 8"
              Identifier ret
                 Type: uint256
                 Source: "ret"
              Literal, token: [no token] value: 8
                 Type: int_const 8
                 Source: "8"
          ExpressionStatement
             Source: "self = bytes32(uint(self) / 0x10000000000000000)"
            Assignment using operator =
               Type: bytes32
               Source: "self = bytes32(uint(self) / 0x10000000000000000)"
              Identifier self
                 Type: bytes32
                 Source: "self"
              FunctionCall
                 Type: bytes32
                 Source: "bytes32(uint(self) / 0x10000000000000000)"
                ElementaryTypeNameExpression bytes32
                   Type: type(bytes32)
                   Source: "bytes32"
                BinaryOperation using operator /
                   Type: uint256
                   Source: "uint(self) / 0x10000000000000000"
                  FunctionCall
                     Type: uint256
                     Source: "uint(self)"
                    ElementaryTypeNameExpression uint
                       Type: type(uint256)
                       Source: "uint"
                    Identifier self
                       Type: bytes32
                       Source: "self"
                  Literal, token: [no token] value: 0x10000000000000000
                     Type: int_const 18446744073709551616
                     Source: "0x10000000000000000"
      IfStatement
         Source: "if (self & 0xffffffff == 0) {\n            ret += 4;\n            self = bytes32(uint(self) / 0x100000000);\n        }"
        BinaryOperation using operator ==
           Type: bool
           Source: "self & 0xffffffff == 0"
          BinaryOperation using operator &
             Type: bytes32
             Source: "self & 0xffffffff"
            Identifier self
               Type: bytes32
               Source: "self"
            Literal, token: [no token] value: 0xffffffff
               Type: int_const 4294967295
               Source: "0xffffffff"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\n            ret += 4;\n            self = bytes32(uint(self) / 0x100000000);\n        }"
          ExpressionStatement
             Source: "ret += 4"
            Assignment using operator +=
               Type: uint256
               Source: "ret += 4"
              Identifier ret
                 Type: uint256
                 Source: "ret"
              Literal, token: [no token] value: 4
                 Type: int_const 4
                 Source: "4"
          ExpressionStatement
             Source: "self = bytes32(uint(self) / 0x100000000)"
            Assignment using operator =
               Type: bytes32
               Source: "self = bytes32(uint(self) / 0x100000000)"
              Identifier self
                 Type: bytes32
                 Source: "self"
              FunctionCall
                 Type: bytes32
                 Source: "bytes32(uint(self) / 0x100000000)"
                ElementaryTypeNameExpression bytes32
                   Type: type(bytes32)
                   Source: "bytes32"
                BinaryOperation using operator /
                   Type: uint256
                   Source: "uint(self) / 0x100000000"
                  FunctionCall
                     Type: uint256
                     Source: "uint(self)"
                    ElementaryTypeNameExpression uint
                       Type: type(uint256)
                       Source: "uint"
                    Identifier self
                       Type: bytes32
                       Source: "self"
                  Literal, token: [no token] value: 0x100000000
                     Type: int_const 4294967296
                     Source: "0x100000000"
      IfStatement
         Source: "if (self & 0xffff == 0) {\n            ret += 2;\n            self = bytes32(uint(self) / 0x10000);\n        }"
        BinaryOperation using operator ==
           Type: bool
           Source: "self & 0xffff == 0"
          BinaryOperation using operator &
             Type: bytes32
             Source: "self & 0xffff"
            Identifier self
               Type: bytes32
               Source: "self"
            Literal, token: [no token] value: 0xffff
               Type: int_const 65535
               Source: "0xffff"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\n            ret += 2;\n            self = bytes32(uint(self) / 0x10000);\n        }"
          ExpressionStatement
             Source: "ret += 2"
            Assignment using operator +=
               Type: uint256
               Source: "ret += 2"
              Identifier ret
                 Type: uint256
                 Source: "ret"
              Literal, token: [no token] value: 2
                 Type: int_const 2
                 Source: "2"
          ExpressionStatement
             Source: "self = bytes32(uint(self) / 0x10000)"
            Assignment using operator =
               Type: bytes32
               Source: "self = bytes32(uint(self) / 0x10000)"
              Identifier self
                 Type: bytes32
                 Source: "self"
              FunctionCall
                 Type: bytes32
                 Source: "bytes32(uint(self) / 0x10000)"
                ElementaryTypeNameExpression bytes32
                   Type: type(bytes32)
                   Source: "bytes32"
                BinaryOperation using operator /
                   Type: uint256
                   Source: "uint(self) / 0x10000"
                  FunctionCall
                     Type: uint256
                     Source: "uint(self)"
                    ElementaryTypeNameExpression uint
                       Type: type(uint256)
                       Source: "uint"
                    Identifier self
                       Type: bytes32
                       Source: "self"
                  Literal, token: [no token] value: 0x10000
                     Type: int_const 65536
                     Source: "0x10000"
      IfStatement
         Source: "if (self & 0xff == 0) {\n            ret += 1;\n        }"
        BinaryOperation using operator ==
           Type: bool
           Source: "self & 0xff == 0"
          BinaryOperation using operator &
             Type: bytes32
             Source: "self & 0xff"
            Identifier self
               Type: bytes32
               Source: "self"
            Literal, token: [no token] value: 0xff
               Type: int_const 255
               Source: "0xff"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\n            ret += 1;\n        }"
          ExpressionStatement
             Source: "ret += 1"
            Assignment using operator +=
               Type: uint256
               Source: "ret += 1"
              Identifier ret
                 Type: uint256
                 Source: "ret"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
      Return
         Source: "return 32 - ret"
        BinaryOperation using operator -
           Type: uint256
           Source: "32 - ret"
          Literal, token: [no token] value: 32
             Type: int_const 32
             Source: "32"
          Identifier ret
             Type: uint256
             Source: "ret"
  FunctionDefinition "toSliceB32"
     Source: "function toSliceB32(bytes32 self) internal returns (slice ret) {\n        // Allocate space for `self` in memory, copy it there, and point ret at it\n        assembly {\n            let ptr := mload(0x40)\n            mstore(0x40, add(ptr, 0x20))\n            mstore(ptr, self)\n            mstore(add(ret, 0x20), ptr)\n        }\n        ret._len = len(self);\n    }"
    ParameterList
       Source: "(bytes32 self)"
      VariableDeclaration "self"
         Type: bytes32
         Source: "bytes32 self"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Source: "(slice ret)"
      VariableDeclaration "ret"
         Type: struct strings.slice memory
         Source: "slice ret"
        UserDefinedTypeName "slice"
           Source: "slice"
    Block
       Source: "{\n        // Allocate space for `self` in memory, copy it there, and point ret at it\n        assembly {\n            let ptr := mload(0x40)\n            mstore(0x40, add(ptr, 0x20))\n            mstore(ptr, self)\n            mstore(add(ret, 0x20), ptr)\n        }\n        ret._len = len(self);\n    }"
      InlineAssembly
         Source: "assembly {\n            let ptr := mload(0x40)\n            mstore(0x40, add(ptr, 0x20))\n            mstore(ptr, self)\n            mstore(add(ret, 0x20), ptr)\n        }\n        ret"
      ExpressionStatement
         Source: "ret._len = len(self)"
        Assignment using operator =
           Type: uint256
           Source: "ret._len = len(self)"
          MemberAccess to member _len
             Type: uint256
             Source: "ret._len"
            Identifier ret
               Type: struct strings.slice memory
               Source: "ret"
          FunctionCall
             Type: uint256
             Source: "len(self)"
            Identifier len
               Type: function (bytes32) returns (uint256)
               Source: "len"
            Identifier self
               Type: bytes32
               Source: "self"
  FunctionDefinition "copy"
     Source: "function copy(slice self) internal returns (slice) {\n        return slice(self._len, self._ptr);\n    }"
    ParameterList
       Source: "(slice self)"
      VariableDeclaration "self"
         Type: struct strings.slice memory
         Source: "slice self"
        UserDefinedTypeName "slice"
           Source: "slice"
    ParameterList
       Source: "(slice)"
      VariableDeclaration ""
         Type: struct strings.slice memory
         Source: "slice"
        UserDefinedTypeName "slice"
           Source: "slice"
    Block
       Source: "{\n        return slice(self._len, self._ptr);\n    }"
      Return
         Source: "return slice(self._len, self._ptr)"
        FunctionCall
           Type: struct strings.slice memory
           Source: "slice(self._len, self._ptr)"
          Identifier slice
             Type: type(struct strings.slice storage pointer)
             Source: "slice"
          MemberAccess to member _len
             Type: uint256
             Source: "self._len"
            Identifier self
               Type: struct strings.slice memory
               Source: "self"
          MemberAccess to member _ptr
             Type: uint256
             Source: "self._ptr"
            Identifier self
               Type: struct strings.slice memory
               Source: "self"
  FunctionDefinition "toString"
     Source: "function toString(slice self) internal returns (string) {\n        var ret = new string(self._len);\n        uint retptr;\n        assembly { retptr := add(ret, 32) }\n\n        memcpy(retptr, self._ptr, self._len);\n        return ret;\n    }"
    ParameterList
       Source: "(slice self)"
      VariableDeclaration "self"
         Type: struct strings.slice memory
         Source: "slice self"
        UserDefinedTypeName "slice"
           Source: "slice"
    ParameterList
       Source: "(string)"
      VariableDeclaration ""
         Type: string memory
         Source: "string"
        ElementaryTypeName string
           Source: "string"
    Block
       Source: "{\n        var ret = new string(self._len);\n        uint retptr;\n        assembly { retptr := add(ret, 32) }\n\n        memcpy(retptr, self._ptr, self._len);\n        return ret;\n    }"
      VariableDeclarationStatement
         Source: "var ret = new string(self._len)"
        VariableDeclaration "ret"
           Type: string memory
           Source: "var ret"
        FunctionCall
           Type: string memory
           Source: "new string(self._len)"
          NewExpression
             Type: function (uint256) pure returns (string memory)
             Source: "new string"
            ElementaryTypeName string
               Source: "string"
          MemberAccess to member _len
             Type: uint256
             Source: "self._len"
            Identifier self
               Type: struct strings.slice memory
               Source: "self"
      VariableDeclarationStatement
         Source: "uint retptr"
        VariableDeclaration "retptr"
           Type: uint256
           Source: "uint retptr"
          ElementaryTypeName uint
             Source: "uint"
      InlineAssembly
         Source: "assembly { retptr := add(ret, 32) }\n\n        memcpy"
      ExpressionStatement
         Source: "memcpy(retptr, self._ptr, self._len)"
        FunctionCall
           Type: tuple()
           Source: "memcpy(retptr, self._ptr, self._len)"
          Identifier memcpy
             Type: function (uint256,uint256,uint256)
             Source: "memcpy"
          Identifier retptr
             Type: uint256
             Source: "retptr"
          MemberAccess to member _ptr
             Type: uint256
             Source: "self._ptr"
            Identifier self
               Type: struct strings.slice memory
               Source: "self"
          MemberAccess to member _len
             Type: uint256
             Source: "self._len"
            Identifier self
               Type: struct strings.slice memory
               Source: "self"
      Return
         Source: "return ret"
        Identifier ret
           Type: string memory
           Source: "ret"
  FunctionDefinition "len"
     Source: "function len(slice self) internal returns (uint l) {\n        // Starting at ptr-31 means the LSB will be the byte we care about\n        var ptr = self._ptr - 31;\n        var end = ptr + self._len;\n        for (l = 0; ptr < end; l++) {\n            uint8 b;\n            assembly { b := and(mload(ptr), 0xFF) }\n            if (b < 0x80) {\n                ptr += 1;\n            } else if(b < 0xE0) {\n                ptr += 2;\n            } else if(b < 0xF0) {\n                ptr += 3;\n            } else if(b < 0xF8) {\n                ptr += 4;\n            } else if(b < 0xFC) {\n                ptr += 5;\n            } else {\n                ptr += 6;\n            }\n        }\n    }"
    ParameterList
       Source: "(slice self)"
      VariableDeclaration "self"
         Type: struct strings.slice memory
         Source: "slice self"
        UserDefinedTypeName "slice"
           Source: "slice"
    ParameterList
       Source: "(uint l)"
      VariableDeclaration "l"
         Type: uint256
         Source: "uint l"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\n        // Starting at ptr-31 means the LSB will be the byte we care about\n        var ptr = self._ptr - 31;\n        var end = ptr + self._len;\n        for (l = 0; ptr < end; l++) {\n            uint8 b;\n            assembly { b := and(mload(ptr), 0xFF) }\n            if (b < 0x80) {\n                ptr += 1;\n            } else if(b < 0xE0) {\n                ptr += 2;\n            } else if(b < 0xF0) {\n                ptr += 3;\n            } else if(b < 0xF8) {\n                ptr += 4;\n            } else if(b < 0xFC) {\n                ptr += 5;\n            } else {\n                ptr += 6;\n            }\n        }\n    }"
      VariableDeclarationStatement
         Source: "var ptr = self._ptr - 31"
        VariableDeclaration "ptr"
           Type: uint256
           Source: "var ptr"
        BinaryOperation using operator -
           Type: uint256
           Source: "self._ptr - 31"
          MemberAccess to member _ptr
             Type: uint256
             Source: "self._ptr"
            Identifier self
               Type: struct strings.slice memory
               Source: "self"
          Literal, token: [no token] value: 31
             Type: int_const 31
             Source: "31"
      VariableDeclarationStatement
         Source: "var end = ptr + self._len"
        VariableDeclaration "end"
           Type: uint256
           Source: "var end"
        BinaryOperation using operator +
           Type: uint256
           Source: "ptr + self._len"
          Identifier ptr
             Type: uint256
             Source: "ptr"
          MemberAccess to member _len
             Type: uint256
             Source: "self._len"
            Identifier self
               Type: struct strings.slice memory
               Source: "self"
      ForStatement
         Source: "for (l = 0; ptr < end; l++) {\n            uint8 b;\n            assembly { b := and(mload(ptr), 0xFF) }\n            if (b < 0x80) {\n                ptr += 1;\n            } else if(b < 0xE0) {\n                ptr += 2;\n            } else if(b < 0xF0) {\n                ptr += 3;\n            } else if(b < 0xF8) {\n                ptr += 4;\n            } else if(b < 0xFC) {\n                ptr += 5;\n            } else {\n                ptr += 6;\n            }\n        }"
        ExpressionStatement
           Source: "l = 0"
          Assignment using operator =
             Type: uint256
             Source: "l = 0"
            Identifier l
               Type: uint256
               Source: "l"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        BinaryOperation using operator <
           Type: bool
           Source: "ptr < end"
          Identifier ptr
             Type: uint256
             Source: "ptr"
          Identifier end
             Type: uint256
             Source: "end"
        ExpressionStatement
           Source: "l++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "l++"
            Identifier l
               Type: uint256
               Source: "l"
        Block
           Source: "{\n            uint8 b;\n            assembly { b := and(mload(ptr), 0xFF) }\n            if (b < 0x80) {\n                ptr += 1;\n            } else if(b < 0xE0) {\n                ptr += 2;\n            } else if(b < 0xF0) {\n                ptr += 3;\n            } else if(b < 0xF8) {\n                ptr += 4;\n            } else if(b < 0xFC) {\n                ptr += 5;\n            } else {\n                ptr += 6;\n            }\n        }"
          VariableDeclarationStatement
             Source: "uint8 b"
            VariableDeclaration "b"
               Type: uint8
               Source: "uint8 b"
              ElementaryTypeName uint8
                 Source: "uint8"
          InlineAssembly
             Source: "assembly { b := and(mload(ptr), 0xFF) }\n            if"
          IfStatement
             Source: "if (b < 0x80) {\n                ptr += 1;\n            } else if(b < 0xE0) {\n                ptr += 2;\n            } else if(b < 0xF0) {\n                ptr += 3;\n            } else if(b < 0xF8) {\n                ptr += 4;\n            } else if(b < 0xFC) {\n                ptr += 5;\n            } else {\n                ptr += 6;\n            }"
            BinaryOperation using operator <
               Type: bool
               Source: "b < 0x80"
              Identifier b
                 Type: uint8
                 Source: "b"
              Literal, token: [no token] value: 0x80
                 Type: int_const 128
                 Source: "0x80"
            Block
               Source: "{\n                ptr += 1;\n            }"
              ExpressionStatement
                 Source: "ptr += 1"
                Assignment using operator +=
                   Type: uint256
                   Source: "ptr += 1"
                  Identifier ptr
                     Type: uint256
                     Source: "ptr"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
            IfStatement
               Source: "if(b < 0xE0) {\n                ptr += 2;\n            } else if(b < 0xF0) {\n                ptr += 3;\n            } else if(b < 0xF8) {\n                ptr += 4;\n            } else if(b < 0xFC) {\n                ptr += 5;\n            } else {\n                ptr += 6;\n            }"
              BinaryOperation using operator <
                 Type: bool
                 Source: "b < 0xE0"
                Identifier b
                   Type: uint8
                   Source: "b"
                Literal, token: [no token] value: 0xE0
                   Type: int_const 224
                   Source: "0xE0"
              Block
                 Source: "{\n                ptr += 2;\n            }"
                ExpressionStatement
                   Source: "ptr += 2"
                  Assignment using operator +=
                     Type: uint256
                     Source: "ptr += 2"
                    Identifier ptr
                       Type: uint256
                       Source: "ptr"
                    Literal, token: [no token] value: 2
                       Type: int_const 2
                       Source: "2"
              IfStatement
                 Source: "if(b < 0xF0) {\n                ptr += 3;\n            } else if(b < 0xF8) {\n                ptr += 4;\n            } else if(b < 0xFC) {\n                ptr += 5;\n            } else {\n                ptr += 6;\n            }"
                BinaryOperation using operator <
                   Type: bool
                   Source: "b < 0xF0"
                  Identifier b
                     Type: uint8
                     Source: "b"
                  Literal, token: [no token] value: 0xF0
                     Type: int_const 240
                     Source: "0xF0"
                Block
                   Source: "{\n                ptr += 3;\n            }"
                  ExpressionStatement
                     Source: "ptr += 3"
                    Assignment using operator +=
                       Type: uint256
                       Source: "ptr += 3"
                      Identifier ptr
                         Type: uint256
                         Source: "ptr"
                      Literal, token: [no token] value: 3
                         Type: int_const 3
                         Source: "3"
                IfStatement
                   Source: "if(b < 0xF8) {\n                ptr += 4;\n            } else if(b < 0xFC) {\n                ptr += 5;\n            } else {\n                ptr += 6;\n            }"
                  BinaryOperation using operator <
                     Type: bool
                     Source: "b < 0xF8"
                    Identifier b
                       Type: uint8
                       Source: "b"
                    Literal, token: [no token] value: 0xF8
                       Type: int_const 248
                       Source: "0xF8"
                  Block
                     Source: "{\n                ptr += 4;\n            }"
                    ExpressionStatement
                       Source: "ptr += 4"
                      Assignment using operator +=
                         Type: uint256
                         Source: "ptr += 4"
                        Identifier ptr
                           Type: uint256
                           Source: "ptr"
                        Literal, token: [no token] value: 4
                           Type: int_const 4
                           Source: "4"
                  IfStatement
                     Source: "if(b < 0xFC) {\n                ptr += 5;\n            } else {\n                ptr += 6;\n            }"
                    BinaryOperation using operator <
                       Type: bool
                       Source: "b < 0xFC"
                      Identifier b
                         Type: uint8
                         Source: "b"
                      Literal, token: [no token] value: 0xFC
                         Type: int_const 252
                         Source: "0xFC"
                    Block
                       Source: "{\n                ptr += 5;\n            }"
                      ExpressionStatement
                         Source: "ptr += 5"
                        Assignment using operator +=
                           Type: uint256
                           Source: "ptr += 5"
                          Identifier ptr
                             Type: uint256
                             Source: "ptr"
                          Literal, token: [no token] value: 5
                             Type: int_const 5
                             Source: "5"
                    Block
                       Source: "{\n                ptr += 6;\n            }"
                      ExpressionStatement
                         Source: "ptr += 6"
                        Assignment using operator +=
                           Type: uint256
                           Source: "ptr += 6"
                          Identifier ptr
                             Type: uint256
                             Source: "ptr"
                          Literal, token: [no token] value: 6
                             Type: int_const 6
                             Source: "6"
  FunctionDefinition "empty"
     Source: "function empty(slice self) internal returns (bool) {\n        return self._len == 0;\n    }"
    ParameterList
       Source: "(slice self)"
      VariableDeclaration "self"
         Type: struct strings.slice memory
         Source: "slice self"
        UserDefinedTypeName "slice"
           Source: "slice"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\n        return self._len == 0;\n    }"
      Return
         Source: "return self._len == 0"
        BinaryOperation using operator ==
           Type: bool
           Source: "self._len == 0"
          MemberAccess to member _len
             Type: uint256
             Source: "self._len"
            Identifier self
               Type: struct strings.slice memory
               Source: "self"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
  FunctionDefinition "compare"
     Source: "function compare(slice self, slice other) internal returns (int) {\n        uint shortest = self._len;\n        if (other._len < self._len)\n            shortest = other._len;\n\n        var selfptr = self._ptr;\n        var otherptr = other._ptr;\n        for (uint idx = 0; idx < shortest; idx += 32) {\n            uint a;\n            uint b;\n            assembly {\n                a := mload(selfptr)\n                b := mload(otherptr)\n            }\n            if (a != b) {\n                // Mask out irrelevant bytes and check again\n                uint mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\n                var diff = (a & mask) - (b & mask);\n                if (diff != 0)\n                    return int(diff);\n            }\n            selfptr += 32;\n            otherptr += 32;\n        }\n        return int(self._len) - int(other._len);\n    }"
    ParameterList
       Source: "(slice self, slice other)"
      VariableDeclaration "self"
         Type: struct strings.slice memory
         Source: "slice self"
        UserDefinedTypeName "slice"
           Source: "slice"
      VariableDeclaration "other"
         Type: struct strings.slice memory
         Source: "slice other"
        UserDefinedTypeName "slice"
           Source: "slice"
    ParameterList
       Source: "(int)"
      VariableDeclaration ""
         Type: int256
         Source: "int"
        ElementaryTypeName int
           Source: "int"
    Block
       Source: "{\n        uint shortest = self._len;\n        if (other._len < self._len)\n            shortest = other._len;\n\n        var selfptr = self._ptr;\n        var otherptr = other._ptr;\n        for (uint idx = 0; idx < shortest; idx += 32) {\n            uint a;\n            uint b;\n            assembly {\n                a := mload(selfptr)\n                b := mload(otherptr)\n            }\n            if (a != b) {\n                // Mask out irrelevant bytes and check again\n                uint mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\n                var diff = (a & mask) - (b & mask);\n                if (diff != 0)\n                    return int(diff);\n            }\n            selfptr += 32;\n            otherptr += 32;\n        }\n        return int(self._len) - int(other._len);\n    }"
      VariableDeclarationStatement
         Source: "uint shortest = self._len"
        VariableDeclaration "shortest"
           Type: uint256
           Source: "uint shortest"
          ElementaryTypeName uint
             Source: "uint"
        MemberAccess to member _len
           Type: uint256
           Source: "self._len"
          Identifier self
             Type: struct strings.slice memory
             Source: "self"
      IfStatement
         Source: "if (other._len < self._len)\n            shortest = other._len"
        BinaryOperation using operator <
           Type: bool
           Source: "other._len < self._len"
          MemberAccess to member _len
             Type: uint256
             Source: "other._len"
            Identifier other
               Type: struct strings.slice memory
               Source: "other"
          MemberAccess to member _len
             Type: uint256
             Source: "self._len"
            Identifier self
               Type: struct strings.slice memory
               Source: "self"
        ExpressionStatement
           Source: "shortest = other._len"
          Assignment using operator =
             Type: uint256
             Source: "shortest = other._len"
            Identifier shortest
               Type: uint256
               Source: "shortest"
            MemberAccess to member _len
               Type: uint256
               Source: "other._len"
              Identifier other
                 Type: struct strings.slice memory
                 Source: "other"
      VariableDeclarationStatement
         Source: "var selfptr = self._ptr"
        VariableDeclaration "selfptr"
           Type: uint256
           Source: "var selfptr"
        MemberAccess to member _ptr
           Type: uint256
           Source: "self._ptr"
          Identifier self
             Type: struct strings.slice memory
             Source: "self"
      VariableDeclarationStatement
         Source: "var otherptr = other._ptr"
        VariableDeclaration "otherptr"
           Type: uint256
           Source: "var otherptr"
        MemberAccess to member _ptr
           Type: uint256
           Source: "other._ptr"
          Identifier other
             Type: struct strings.slice memory
             Source: "other"
      ForStatement
         Source: "for (uint idx = 0; idx < shortest; idx += 32) {\n            uint a;\n            uint b;\n            assembly {\n                a := mload(selfptr)\n                b := mload(otherptr)\n            }\n            if (a != b) {\n                // Mask out irrelevant bytes and check again\n                uint mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\n                var diff = (a & mask) - (b & mask);\n                if (diff != 0)\n                    return int(diff);\n            }\n            selfptr += 32;\n            otherptr += 32;\n        }"
        VariableDeclarationStatement
           Source: "uint idx = 0"
          VariableDeclaration "idx"
             Type: uint256
             Source: "uint idx"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Source: "idx < shortest"
          Identifier idx
             Type: uint256
             Source: "idx"
          Identifier shortest
             Type: uint256
             Source: "shortest"
        ExpressionStatement
           Source: "idx += 32"
          Assignment using operator +=
             Type: uint256
             Source: "idx += 32"
            Identifier idx
               Type: uint256
               Source: "idx"
            Literal, token: [no token] value: 32
               Type: int_const 32
               Source: "32"
        Block
           Source: "{\n            uint a;\n            uint b;\n            assembly {\n                a := mload(selfptr)\n                b := mload(otherptr)\n            }\n            if (a != b) {\n                // Mask out irrelevant bytes and check again\n                uint mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\n                var diff = (a & mask) - (b & mask);\n                if (diff != 0)\n                    return int(diff);\n            }\n            selfptr += 32;\n            otherptr += 32;\n        }"
          VariableDeclarationStatement
             Source: "uint a"
            VariableDeclaration "a"
               Type: uint256
               Source: "uint a"
              ElementaryTypeName uint
                 Source: "uint"
          VariableDeclarationStatement
             Source: "uint b"
            VariableDeclaration "b"
               Type: uint256
               Source: "uint b"
              ElementaryTypeName uint
                 Source: "uint"
          InlineAssembly
             Source: "assembly {\n                a := mload(selfptr)\n                b := mload(otherptr)\n            }\n            if"
          IfStatement
             Source: "if (a != b) {\n                // Mask out irrelevant bytes and check again\n                uint mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\n                var diff = (a & mask) - (b & mask);\n                if (diff != 0)\n                    return int(diff);\n            }"
            BinaryOperation using operator !=
               Type: bool
               Source: "a != b"
              Identifier a
                 Type: uint256
                 Source: "a"
              Identifier b
                 Type: uint256
                 Source: "b"
            Block
               Source: "{\n                // Mask out irrelevant bytes and check again\n                uint mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\n                var diff = (a & mask) - (b & mask);\n                if (diff != 0)\n                    return int(diff);\n            }"
              VariableDeclarationStatement
                 Source: "uint mask = ~(2 ** (8 * (32 - shortest + idx)) - 1)"
                VariableDeclaration "mask"
                   Type: uint256
                   Source: "uint mask"
                  ElementaryTypeName uint
                     Source: "uint"
                UnaryOperation (prefix) ~
                   Type: uint256
                   Source: "~(2 ** (8 * (32 - shortest + idx)) - 1)"
                  TupleExpression
                     Type: uint256
                     Source: "(2 ** (8 * (32 - shortest + idx)) - 1)"
                    BinaryOperation using operator -
                       Type: uint256
                       Source: "2 ** (8 * (32 - shortest + idx)) - 1"
                      BinaryOperation using operator **
                         Type: uint256
                         Source: "2 ** (8 * (32 - shortest + idx))"
                        Literal, token: [no token] value: 2
                           Type: int_const 2
                           Source: "2"
                        TupleExpression
                           Type: uint256
                           Source: "(8 * (32 - shortest + idx))"
                          BinaryOperation using operator *
                             Type: uint256
                             Source: "8 * (32 - shortest + idx)"
                            Literal, token: [no token] value: 8
                               Type: int_const 8
                               Source: "8"
                            TupleExpression
                               Type: uint256
                               Source: "(32 - shortest + idx)"
                              BinaryOperation using operator +
                                 Type: uint256
                                 Source: "32 - shortest + idx"
                                BinaryOperation using operator -
                                   Type: uint256
                                   Source: "32 - shortest"
                                  Literal, token: [no token] value: 32
                                     Type: int_const 32
                                     Source: "32"
                                  Identifier shortest
                                     Type: uint256
                                     Source: "shortest"
                                Identifier idx
                                   Type: uint256
                                   Source: "idx"
                      Literal, token: [no token] value: 1
                         Type: int_const 1
                         Source: "1"
              VariableDeclarationStatement
                 Source: "var diff = (a & mask) - (b & mask)"
                VariableDeclaration "diff"
                   Type: uint256
                   Source: "var diff"
                BinaryOperation using operator -
                   Type: uint256
                   Source: "(a & mask) - (b & mask)"
                  TupleExpression
                     Type: uint256
                     Source: "(a & mask)"
                    BinaryOperation using operator &
                       Type: uint256
                       Source: "a & mask"
                      Identifier a
                         Type: uint256
                         Source: "a"
                      Identifier mask
                         Type: uint256
                         Source: "mask"
                  TupleExpression
                     Type: uint256
                     Source: "(b & mask)"
                    BinaryOperation using operator &
                       Type: uint256
                       Source: "b & mask"
                      Identifier b
                         Type: uint256
                         Source: "b"
                      Identifier mask
                         Type: uint256
                         Source: "mask"
              IfStatement
                 Source: "if (diff != 0)\n                    return int(diff)"
                BinaryOperation using operator !=
                   Type: bool
                   Source: "diff != 0"
                  Identifier diff
                     Type: uint256
                     Source: "diff"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
                Return
                   Source: "return int(diff)"
                  FunctionCall
                     Type: int256
                     Source: "int(diff)"
                    ElementaryTypeNameExpression int
                       Type: type(int256)
                       Source: "int"
                    Identifier diff
                       Type: uint256
                       Source: "diff"
          ExpressionStatement
             Source: "selfptr += 32"
            Assignment using operator +=
               Type: uint256
               Source: "selfptr += 32"
              Identifier selfptr
                 Type: uint256
                 Source: "selfptr"
              Literal, token: [no token] value: 32
                 Type: int_const 32
                 Source: "32"
          ExpressionStatement
             Source: "otherptr += 32"
            Assignment using operator +=
               Type: uint256
               Source: "otherptr += 32"
              Identifier otherptr
                 Type: uint256
                 Source: "otherptr"
              Literal, token: [no token] value: 32
                 Type: int_const 32
                 Source: "32"
      Return
         Source: "return int(self._len) - int(other._len)"
        BinaryOperation using operator -
           Type: int256
           Source: "int(self._len) - int(other._len)"
          FunctionCall
             Type: int256
             Source: "int(self._len)"
            ElementaryTypeNameExpression int
               Type: type(int256)
               Source: "int"
            MemberAccess to member _len
               Type: uint256
               Source: "self._len"
              Identifier self
                 Type: struct strings.slice memory
                 Source: "self"
          FunctionCall
             Type: int256
             Source: "int(other._len)"
            ElementaryTypeNameExpression int
               Type: type(int256)
               Source: "int"
            MemberAccess to member _len
               Type: uint256
               Source: "other._len"
              Identifier other
                 Type: struct strings.slice memory
                 Source: "other"
  FunctionDefinition "equals"
     Source: "function equals(slice self, slice other) internal returns (bool) {\n        return compare(self, other) == 0;\n    }"
    ParameterList
       Source: "(slice self, slice other)"
      VariableDeclaration "self"
         Type: struct strings.slice memory
         Source: "slice self"
        UserDefinedTypeName "slice"
           Source: "slice"
      VariableDeclaration "other"
         Type: struct strings.slice memory
         Source: "slice other"
        UserDefinedTypeName "slice"
           Source: "slice"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\n        return compare(self, other) == 0;\n    }"
      Return
         Source: "return compare(self, other) == 0"
        BinaryOperation using operator ==
           Type: bool
           Source: "compare(self, other) == 0"
          FunctionCall
             Type: int256
             Source: "compare(self, other)"
            Identifier compare
               Type: function (struct strings.slice memory,struct strings.slice memory) returns (int256)
               Source: "compare"
            Identifier self
               Type: struct strings.slice memory
               Source: "self"
            Identifier other
               Type: struct strings.slice memory
               Source: "other"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
  FunctionDefinition "nextRune"
     Source: "function nextRune(slice self, slice rune) internal returns (slice) {\n        rune._ptr = self._ptr;\n\n        if (self._len == 0) {\n            rune._len = 0;\n            return rune;\n        }\n\n        uint len;\n        uint b;\n        // Load the first byte of the rune into the LSBs of b\n        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\n        if (b < 0x80) {\n            len = 1;\n        } else if(b < 0xE0) {\n            len = 2;\n        } else if(b < 0xF0) {\n            len = 3;\n        } else {\n            len = 4;\n        }\n\n        // Check for truncated codepoints\n        if (len > self._len) {\n            rune._len = self._len;\n            self._ptr += self._len;\n            self._len = 0;\n            return rune;\n        }\n\n        self._ptr += len;\n        self._len -= len;\n        rune._len = len;\n        return rune;\n    }"
    ParameterList
       Source: "(slice self, slice rune)"
      VariableDeclaration "self"
         Type: struct strings.slice memory
         Source: "slice self"
        UserDefinedTypeName "slice"
           Source: "slice"
      VariableDeclaration "rune"
         Type: struct strings.slice memory
         Source: "slice rune"
        UserDefinedTypeName "slice"
           Source: "slice"
    ParameterList
       Source: "(slice)"
      VariableDeclaration ""
         Type: struct strings.slice memory
         Source: "slice"
        UserDefinedTypeName "slice"
           Source: "slice"
    Block
       Source: "{\n        rune._ptr = self._ptr;\n\n        if (self._len == 0) {\n            rune._len = 0;\n            return rune;\n        }\n\n        uint len;\n        uint b;\n        // Load the first byte of the rune into the LSBs of b\n        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\n        if (b < 0x80) {\n            len = 1;\n        } else if(b < 0xE0) {\n            len = 2;\n        } else if(b < 0xF0) {\n            len = 3;\n        } else {\n            len = 4;\n        }\n\n        // Check for truncated codepoints\n        if (len > self._len) {\n            rune._len = self._len;\n            self._ptr += self._len;\n            self._len = 0;\n            return rune;\n        }\n\n        self._ptr += len;\n        self._len -= len;\n        rune._len = len;\n        return rune;\n    }"
      ExpressionStatement
         Source: "rune._ptr = self._ptr"
        Assignment using operator =
           Type: uint256
           Source: "rune._ptr = self._ptr"
          MemberAccess to member _ptr
             Type: uint256
             Source: "rune._ptr"
            Identifier rune
               Type: struct strings.slice memory
               Source: "rune"
          MemberAccess to member _ptr
             Type: uint256
             Source: "self._ptr"
            Identifier self
               Type: struct strings.slice memory
               Source: "self"
      IfStatement
         Source: "if (self._len == 0) {\n            rune._len = 0;\n            return rune;\n        }"
        BinaryOperation using operator ==
           Type: bool
           Source: "self._len == 0"
          MemberAccess to member _len
             Type: uint256
             Source: "self._len"
            Identifier self
               Type: struct strings.slice memory
               Source: "self"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\n            rune._len = 0;\n            return rune;\n        }"
          ExpressionStatement
             Source: "rune._len = 0"
            Assignment using operator =
               Type: uint256
               Source: "rune._len = 0"
              MemberAccess to member _len
                 Type: uint256
                 Source: "rune._len"
                Identifier rune
                   Type: struct strings.slice memory
                   Source: "rune"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          Return
             Source: "return rune"
            Identifier rune
               Type: struct strings.slice memory
               Source: "rune"
      VariableDeclarationStatement
         Source: "uint len"
        VariableDeclaration "len"
           Type: uint256
           Source: "uint len"
          ElementaryTypeName uint
             Source: "uint"
      VariableDeclarationStatement
         Source: "uint b"
        VariableDeclaration "b"
           Type: uint256
           Source: "uint b"
          ElementaryTypeName uint
             Source: "uint"
      InlineAssembly
         Source: "assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\n        if"
      IfStatement
         Source: "if (b < 0x80) {\n            len = 1;\n        } else if(b < 0xE0) {\n            len = 2;\n        } else if(b < 0xF0) {\n            len = 3;\n        } else {\n            len = 4;\n        }"
        BinaryOperation using operator <
           Type: bool
           Source: "b < 0x80"
          Identifier b
             Type: uint256
             Source: "b"
          Literal, token: [no token] value: 0x80
             Type: int_const 128
             Source: "0x80"
        Block
           Source: "{\n            len = 1;\n        }"
          ExpressionStatement
             Source: "len = 1"
            Assignment using operator =
               Type: uint256
               Source: "len = 1"
              Identifier len
                 Type: uint256
                 Source: "len"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
        IfStatement
           Source: "if(b < 0xE0) {\n            len = 2;\n        } else if(b < 0xF0) {\n            len = 3;\n        } else {\n            len = 4;\n        }"
          BinaryOperation using operator <
             Type: bool
             Source: "b < 0xE0"
            Identifier b
               Type: uint256
               Source: "b"
            Literal, token: [no token] value: 0xE0
               Type: int_const 224
               Source: "0xE0"
          Block
             Source: "{\n            len = 2;\n        }"
            ExpressionStatement
               Source: "len = 2"
              Assignment using operator =
                 Type: uint256
                 Source: "len = 2"
                Identifier len
                   Type: uint256
                   Source: "len"
                Literal, token: [no token] value: 2
                   Type: int_const 2
                   Source: "2"
          IfStatement
             Source: "if(b < 0xF0) {\n            len = 3;\n        } else {\n            len = 4;\n        }"
            BinaryOperation using operator <
               Type: bool
               Source: "b < 0xF0"
              Identifier b
                 Type: uint256
                 Source: "b"
              Literal, token: [no token] value: 0xF0
                 Type: int_const 240
                 Source: "0xF0"
            Block
               Source: "{\n            len = 3;\n        }"
              ExpressionStatement
                 Source: "len = 3"
                Assignment using operator =
                   Type: uint256
                   Source: "len = 3"
                  Identifier len
                     Type: uint256
                     Source: "len"
                  Literal, token: [no token] value: 3
                     Type: int_const 3
                     Source: "3"
            Block
               Source: "{\n            len = 4;\n        }"
              ExpressionStatement
                 Source: "len = 4"
                Assignment using operator =
                   Type: uint256
                   Source: "len = 4"
                  Identifier len
                     Type: uint256
                     Source: "len"
                  Literal, token: [no token] value: 4
                     Type: int_const 4
                     Source: "4"
      IfStatement
         Source: "if (len > self._len) {\n            rune._len = self._len;\n            self._ptr += self._len;\n            self._len = 0;\n            return rune;\n        }"
        BinaryOperation using operator >
           Type: bool
           Source: "len > self._len"
          Identifier len
             Type: uint256
             Source: "len"
          MemberAccess to member _len
             Type: uint256
             Source: "self._len"
            Identifier self
               Type: struct strings.slice memory
               Source: "self"
        Block
           Source: "{\n            rune._len = self._len;\n            self._ptr += self._len;\n            self._len = 0;\n            return rune;\n        }"
          ExpressionStatement
             Source: "rune._len = self._len"
            Assignment using operator =
               Type: uint256
               Source: "rune._len = self._len"
              MemberAccess to member _len
                 Type: uint256
                 Source: "rune._len"
                Identifier rune
                   Type: struct strings.slice memory
                   Source: "rune"
              MemberAccess to member _len
                 Type: uint256
                 Source: "self._len"
                Identifier self
                   Type: struct strings.slice memory
                   Source: "self"
          ExpressionStatement
             Source: "self._ptr += self._len"
            Assignment using operator +=
               Type: uint256
               Source: "self._ptr += self._len"
              MemberAccess to member _ptr
                 Type: uint256
                 Source: "self._ptr"
                Identifier self
                   Type: struct strings.slice memory
                   Source: "self"
              MemberAccess to member _len
                 Type: uint256
                 Source: "self._len"
                Identifier self
                   Type: struct strings.slice memory
                   Source: "self"
          ExpressionStatement
             Source: "self._len = 0"
            Assignment using operator =
               Type: uint256
               Source: "self._len = 0"
              MemberAccess to member _len
                 Type: uint256
                 Source: "self._len"
                Identifier self
                   Type: struct strings.slice memory
                   Source: "self"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          Return
             Source: "return rune"
            Identifier rune
               Type: struct strings.slice memory
               Source: "rune"
      ExpressionStatement
         Source: "self._ptr += len"
        Assignment using operator +=
           Type: uint256
           Source: "self._ptr += len"
          MemberAccess to member _ptr
             Type: uint256
             Source: "self._ptr"
            Identifier self
               Type: struct strings.slice memory
               Source: "self"
          Identifier len
             Type: uint256
             Source: "len"
      ExpressionStatement
         Source: "self._len -= len"
        Assignment using operator -=
           Type: uint256
           Source: "self._len -= len"
          MemberAccess to member _len
             Type: uint256
             Source: "self._len"
            Identifier self
               Type: struct strings.slice memory
               Source: "self"
          Identifier len
             Type: uint256
             Source: "len"
      ExpressionStatement
         Source: "rune._len = len"
        Assignment using operator =
           Type: uint256
           Source: "rune._len = len"
          MemberAccess to member _len
             Type: uint256
             Source: "rune._len"
            Identifier rune
               Type: struct strings.slice memory
               Source: "rune"
          Identifier len
             Type: uint256
             Source: "len"
      Return
         Source: "return rune"
        Identifier rune
           Type: struct strings.slice memory
           Source: "rune"
  FunctionDefinition "nextRune"
     Source: "function nextRune(slice self) internal returns (slice ret) {\n        nextRune(self, ret);\n    }"
    ParameterList
       Source: "(slice self)"
      VariableDeclaration "self"
         Type: struct strings.slice memory
         Source: "slice self"
        UserDefinedTypeName "slice"
           Source: "slice"
    ParameterList
       Source: "(slice ret)"
      VariableDeclaration "ret"
         Type: struct strings.slice memory
         Source: "slice ret"
        UserDefinedTypeName "slice"
           Source: "slice"
    Block
       Source: "{\n        nextRune(self, ret);\n    }"
      ExpressionStatement
         Source: "nextRune(self, ret)"
        FunctionCall
           Type: struct strings.slice memory
           Source: "nextRune(self, ret)"
          Identifier nextRune
             Type: function (struct strings.slice memory,struct strings.slice memory) returns (struct strings.slice memory)
             Source: "nextRune"
          Identifier self
             Type: struct strings.slice memory
             Source: "self"
          Identifier ret
             Type: struct strings.slice memory
             Source: "ret"
  FunctionDefinition "ord"
     Source: "function ord(slice self) internal returns (uint ret) {\n        if (self._len == 0) {\n            return 0;\n        }\n\n        uint word;\n        uint length;\n        uint divisor = 2 ** 248;\n\n        // Load the rune into the MSBs of b\n        assembly { word:= mload(mload(add(self, 32))) }\n        var b = word / divisor;\n        if (b < 0x80) {\n            ret = b;\n            length = 1;\n        } else if(b < 0xE0) {\n            ret = b & 0x1F;\n            length = 2;\n        } else if(b < 0xF0) {\n            ret = b & 0x0F;\n            length = 3;\n        } else {\n            ret = b & 0x07;\n            length = 4;\n        }\n\n        // Check for truncated codepoints\n        if (length > self._len) {\n            return 0;\n        }\n\n        for (uint i = 1; i < length; i++) {\n            divisor = divisor / 256;\n            b = (word / divisor) & 0xFF;\n            if (b & 0xC0 != 0x80) {\n                // Invalid UTF-8 sequence\n                return 0;\n            }\n            ret = (ret * 64) | (b & 0x3F);\n        }\n\n        return ret;\n    }"
    ParameterList
       Source: "(slice self)"
      VariableDeclaration "self"
         Type: struct strings.slice memory
         Source: "slice self"
        UserDefinedTypeName "slice"
           Source: "slice"
    ParameterList
       Source: "(uint ret)"
      VariableDeclaration "ret"
         Type: uint256
         Source: "uint ret"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\n        if (self._len == 0) {\n            return 0;\n        }\n\n        uint word;\n        uint length;\n        uint divisor = 2 ** 248;\n\n        // Load the rune into the MSBs of b\n        assembly { word:= mload(mload(add(self, 32))) }\n        var b = word / divisor;\n        if (b < 0x80) {\n            ret = b;\n            length = 1;\n        } else if(b < 0xE0) {\n            ret = b & 0x1F;\n            length = 2;\n        } else if(b < 0xF0) {\n            ret = b & 0x0F;\n            length = 3;\n        } else {\n            ret = b & 0x07;\n            length = 4;\n        }\n\n        // Check for truncated codepoints\n        if (length > self._len) {\n            return 0;\n        }\n\n        for (uint i = 1; i < length; i++) {\n            divisor = divisor / 256;\n            b = (word / divisor) & 0xFF;\n            if (b & 0xC0 != 0x80) {\n                // Invalid UTF-8 sequence\n                return 0;\n            }\n            ret = (ret * 64) | (b & 0x3F);\n        }\n\n        return ret;\n    }"
      IfStatement
         Source: "if (self._len == 0) {\n            return 0;\n        }"
        BinaryOperation using operator ==
           Type: bool
           Source: "self._len == 0"
          MemberAccess to member _len
             Type: uint256
             Source: "self._len"
            Identifier self
               Type: struct strings.slice memory
               Source: "self"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\n            return 0;\n        }"
          Return
             Source: "return 0"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      VariableDeclarationStatement
         Source: "uint word"
        VariableDeclaration "word"
           Type: uint256
           Source: "uint word"
          ElementaryTypeName uint
             Source: "uint"
      VariableDeclarationStatement
         Source: "uint length"
        VariableDeclaration "length"
           Type: uint256
           Source: "uint length"
          ElementaryTypeName uint
             Source: "uint"
      VariableDeclarationStatement
         Source: "uint divisor = 2 ** 248"
        VariableDeclaration "divisor"
           Type: uint256
           Source: "uint divisor"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator **
           Type: int_const 452312848583266388373324160190187140051835877600158453279131187530910662656
           Source: "2 ** 248"
          Literal, token: [no token] value: 2
             Type: int_const 2
             Source: "2"
          Literal, token: [no token] value: 248
             Type: int_const 248
             Source: "248"
      InlineAssembly
         Source: "assembly { word:= mload(mload(add(self, 32))) }\n        var"
      VariableDeclarationStatement
         Source: "var b = word / divisor"
        VariableDeclaration "b"
           Type: uint256
           Source: "var b"
        BinaryOperation using operator /
           Type: uint256
           Source: "word / divisor"
          Identifier word
             Type: uint256
             Source: "word"
          Identifier divisor
             Type: uint256
             Source: "divisor"
      IfStatement
         Source: "if (b < 0x80) {\n            ret = b;\n            length = 1;\n        } else if(b < 0xE0) {\n            ret = b & 0x1F;\n            length = 2;\n        } else if(b < 0xF0) {\n            ret = b & 0x0F;\n            length = 3;\n        } else {\n            ret = b & 0x07;\n            length = 4;\n        }"
        BinaryOperation using operator <
           Type: bool
           Source: "b < 0x80"
          Identifier b
             Type: uint256
             Source: "b"
          Literal, token: [no token] value: 0x80
             Type: int_const 128
             Source: "0x80"
        Block
           Source: "{\n            ret = b;\n            length = 1;\n        }"
          ExpressionStatement
             Source: "ret = b"
            Assignment using operator =
               Type: uint256
               Source: "ret = b"
              Identifier ret
                 Type: uint256
                 Source: "ret"
              Identifier b
                 Type: uint256
                 Source: "b"
          ExpressionStatement
             Source: "length = 1"
            Assignment using operator =
               Type: uint256
               Source: "length = 1"
              Identifier length
                 Type: uint256
                 Source: "length"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
        IfStatement
           Source: "if(b < 0xE0) {\n            ret = b & 0x1F;\n            length = 2;\n        } else if(b < 0xF0) {\n            ret = b & 0x0F;\n            length = 3;\n        } else {\n            ret = b & 0x07;\n            length = 4;\n        }"
          BinaryOperation using operator <
             Type: bool
             Source: "b < 0xE0"
            Identifier b
               Type: uint256
               Source: "b"
            Literal, token: [no token] value: 0xE0
               Type: int_const 224
               Source: "0xE0"
          Block
             Source: "{\n            ret = b & 0x1F;\n            length = 2;\n        }"
            ExpressionStatement
               Source: "ret = b & 0x1F"
              Assignment using operator =
                 Type: uint256
                 Source: "ret = b & 0x1F"
                Identifier ret
                   Type: uint256
                   Source: "ret"
                BinaryOperation using operator &
                   Type: uint256
                   Source: "b & 0x1F"
                  Identifier b
                     Type: uint256
                     Source: "b"
                  Literal, token: [no token] value: 0x1F
                     Type: int_const 31
                     Source: "0x1F"
            ExpressionStatement
               Source: "length = 2"
              Assignment using operator =
                 Type: uint256
                 Source: "length = 2"
                Identifier length
                   Type: uint256
                   Source: "length"
                Literal, token: [no token] value: 2
                   Type: int_const 2
                   Source: "2"
          IfStatement
             Source: "if(b < 0xF0) {\n            ret = b & 0x0F;\n            length = 3;\n        } else {\n            ret = b & 0x07;\n            length = 4;\n        }"
            BinaryOperation using operator <
               Type: bool
               Source: "b < 0xF0"
              Identifier b
                 Type: uint256
                 Source: "b"
              Literal, token: [no token] value: 0xF0
                 Type: int_const 240
                 Source: "0xF0"
            Block
               Source: "{\n            ret = b & 0x0F;\n            length = 3;\n        }"
              ExpressionStatement
                 Source: "ret = b & 0x0F"
                Assignment using operator =
                   Type: uint256
                   Source: "ret = b & 0x0F"
                  Identifier ret
                     Type: uint256
                     Source: "ret"
                  BinaryOperation using operator &
                     Type: uint256
                     Source: "b & 0x0F"
                    Identifier b
                       Type: uint256
                       Source: "b"
                    Literal, token: [no token] value: 0x0F
                       Type: int_const 15
                       Source: "0x0F"
              ExpressionStatement
                 Source: "length = 3"
                Assignment using operator =
                   Type: uint256
                   Source: "length = 3"
                  Identifier length
                     Type: uint256
                     Source: "length"
                  Literal, token: [no token] value: 3
                     Type: int_const 3
                     Source: "3"
            Block
               Source: "{\n            ret = b & 0x07;\n            length = 4;\n        }"
              ExpressionStatement
                 Source: "ret = b & 0x07"
                Assignment using operator =
                   Type: uint256
                   Source: "ret = b & 0x07"
                  Identifier ret
                     Type: uint256
                     Source: "ret"
                  BinaryOperation using operator &
                     Type: uint256
                     Source: "b & 0x07"
                    Identifier b
                       Type: uint256
                       Source: "b"
                    Literal, token: [no token] value: 0x07
                       Type: int_const 7
                       Source: "0x07"
              ExpressionStatement
                 Source: "length = 4"
                Assignment using operator =
                   Type: uint256
                   Source: "length = 4"
                  Identifier length
                     Type: uint256
                     Source: "length"
                  Literal, token: [no token] value: 4
                     Type: int_const 4
                     Source: "4"
      IfStatement
         Source: "if (length > self._len) {\n            return 0;\n        }"
        BinaryOperation using operator >
           Type: bool
           Source: "length > self._len"
          Identifier length
             Type: uint256
             Source: "length"
          MemberAccess to member _len
             Type: uint256
             Source: "self._len"
            Identifier self
               Type: struct strings.slice memory
               Source: "self"
        Block
           Source: "{\n            return 0;\n        }"
          Return
             Source: "return 0"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ForStatement
         Source: "for (uint i = 1; i < length; i++) {\n            divisor = divisor / 256;\n            b = (word / divisor) & 0xFF;\n            if (b & 0xC0 != 0x80) {\n                // Invalid UTF-8 sequence\n                return 0;\n            }\n            ret = (ret * 64) | (b & 0x3F);\n        }"
        VariableDeclarationStatement
           Source: "uint i = 1"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
        BinaryOperation using operator <
           Type: bool
           Source: "i < length"
          Identifier i
             Type: uint256
             Source: "i"
          Identifier length
             Type: uint256
             Source: "length"
        ExpressionStatement
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\n            divisor = divisor / 256;\n            b = (word / divisor) & 0xFF;\n            if (b & 0xC0 != 0x80) {\n                // Invalid UTF-8 sequence\n                return 0;\n            }\n            ret = (ret * 64) | (b & 0x3F);\n        }"
          ExpressionStatement
             Source: "divisor = divisor / 256"
            Assignment using operator =
               Type: uint256
               Source: "divisor = divisor / 256"
              Identifier divisor
                 Type: uint256
                 Source: "divisor"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "divisor / 256"
                Identifier divisor
                   Type: uint256
                   Source: "divisor"
                Literal, token: [no token] value: 256
                   Type: int_const 256
                   Source: "256"
          ExpressionStatement
             Source: "b = (word / divisor) & 0xFF"
            Assignment using operator =
               Type: uint256
               Source: "b = (word / divisor) & 0xFF"
              Identifier b
                 Type: uint256
                 Source: "b"
              BinaryOperation using operator &
                 Type: uint256
                 Source: "(word / divisor) & 0xFF"
                TupleExpression
                   Type: uint256
                   Source: "(word / divisor)"
                  BinaryOperation using operator /
                     Type: uint256
                     Source: "word / divisor"
                    Identifier word
                       Type: uint256
                       Source: "word"
                    Identifier divisor
                       Type: uint256
                       Source: "divisor"
                Literal, token: [no token] value: 0xFF
                   Type: int_const 255
                   Source: "0xFF"
          IfStatement
             Source: "if (b & 0xC0 != 0x80) {\n                // Invalid UTF-8 sequence\n                return 0;\n            }"
            BinaryOperation using operator !=
               Type: bool
               Source: "b & 0xC0 != 0x80"
              BinaryOperation using operator &
                 Type: uint256
                 Source: "b & 0xC0"
                Identifier b
                   Type: uint256
                   Source: "b"
                Literal, token: [no token] value: 0xC0
                   Type: int_const 192
                   Source: "0xC0"
              Literal, token: [no token] value: 0x80
                 Type: int_const 128
                 Source: "0x80"
            Block
               Source: "{\n                // Invalid UTF-8 sequence\n                return 0;\n            }"
              Return
                 Source: "return 0"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
          ExpressionStatement
             Source: "ret = (ret * 64) | (b & 0x3F)"
            Assignment using operator =
               Type: uint256
               Source: "ret = (ret * 64) | (b & 0x3F)"
              Identifier ret
                 Type: uint256
                 Source: "ret"
              BinaryOperation using operator |
                 Type: uint256
                 Source: "(ret * 64) | (b & 0x3F)"
                TupleExpression
                   Type: uint256
                   Source: "(ret * 64)"
                  BinaryOperation using operator *
                     Type: uint256
                     Source: "ret * 64"
                    Identifier ret
                       Type: uint256
                       Source: "ret"
                    Literal, token: [no token] value: 64
                       Type: int_const 64
                       Source: "64"
                TupleExpression
                   Type: uint256
                   Source: "(b & 0x3F)"
                  BinaryOperation using operator &
                     Type: uint256
                     Source: "b & 0x3F"
                    Identifier b
                       Type: uint256
                       Source: "b"
                    Literal, token: [no token] value: 0x3F
                       Type: int_const 63
                       Source: "0x3F"
      Return
         Source: "return ret"
        Identifier ret
           Type: uint256
           Source: "ret"
  FunctionDefinition "keccak"
     Source: "function keccak(slice self) internal returns (bytes32 ret) {\n        assembly {\n            ret := keccak256(mload(add(self, 32)), mload(self))\n        }\n    }"
    ParameterList
       Source: "(slice self)"
      VariableDeclaration "self"
         Type: struct strings.slice memory
         Source: "slice self"
        UserDefinedTypeName "slice"
           Source: "slice"
    ParameterList
       Source: "(bytes32 ret)"
      VariableDeclaration "ret"
         Type: bytes32
         Source: "bytes32 ret"
        ElementaryTypeName bytes32
           Source: "bytes32"
    Block
       Source: "{\n        assembly {\n            ret := keccak256(mload(add(self, 32)), mload(self))\n        }\n    }"
      InlineAssembly
         Source: "assembly {\n            ret := keccak256(mload(add(self, 32)), mload(self))\n        }\n    }"
  FunctionDefinition "startsWith"
     Source: "function startsWith(slice self, slice needle) internal returns (bool) {\n        if (self._len < needle._len) {\n            return false;\n        }\n\n        if (self._ptr == needle._ptr) {\n            return true;\n        }\n\n        bool equal;\n        assembly {\n            let length := mload(needle)\n            let selfptr := mload(add(self, 0x20))\n            let needleptr := mload(add(needle, 0x20))\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n        }\n        return equal;\n    }"
    ParameterList
       Source: "(slice self, slice needle)"
      VariableDeclaration "self"
         Type: struct strings.slice memory
         Source: "slice self"
        UserDefinedTypeName "slice"
           Source: "slice"
      VariableDeclaration "needle"
         Type: struct strings.slice memory
         Source: "slice needle"
        UserDefinedTypeName "slice"
           Source: "slice"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\n        if (self._len < needle._len) {\n            return false;\n        }\n\n        if (self._ptr == needle._ptr) {\n            return true;\n        }\n\n        bool equal;\n        assembly {\n            let length := mload(needle)\n            let selfptr := mload(add(self, 0x20))\n            let needleptr := mload(add(needle, 0x20))\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n        }\n        return equal;\n    }"
      IfStatement
         Source: "if (self._len < needle._len) {\n            return false;\n        }"
        BinaryOperation using operator <
           Type: bool
           Source: "self._len < needle._len"
          MemberAccess to member _len
             Type: uint256
             Source: "self._len"
            Identifier self
               Type: struct strings.slice memory
               Source: "self"
          MemberAccess to member _len
             Type: uint256
             Source: "needle._len"
            Identifier needle
               Type: struct strings.slice memory
               Source: "needle"
        Block
           Source: "{\n            return false;\n        }"
          Return
             Source: "return false"
            Literal, token: false value: false
               Type: bool
               Source: "false"
      IfStatement
         Source: "if (self._ptr == needle._ptr) {\n            return true;\n        }"
        BinaryOperation using operator ==
           Type: bool
           Source: "self._ptr == needle._ptr"
          MemberAccess to member _ptr
             Type: uint256
             Source: "self._ptr"
            Identifier self
               Type: struct strings.slice memory
               Source: "self"
          MemberAccess to member _ptr
             Type: uint256
             Source: "needle._ptr"
            Identifier needle
               Type: struct strings.slice memory
               Source: "needle"
        Block
           Source: "{\n            return true;\n        }"
          Return
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
      VariableDeclarationStatement
         Source: "bool equal"
        VariableDeclaration "equal"
           Type: bool
           Source: "bool equal"
          ElementaryTypeName bool
             Source: "bool"
      InlineAssembly
         Source: "assembly {\n            let length := mload(needle)\n            let selfptr := mload(add(self, 0x20))\n            let needleptr := mload(add(needle, 0x20))\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n        }\n        return"
      Return
         Source: "return equal"
        Identifier equal
           Type: bool
           Source: "equal"
  FunctionDefinition "beyond"
     Source: "function beyond(slice self, slice needle) internal returns (slice) {\n        if (self._len < needle._len) {\n            return self;\n        }\n\n        bool equal = true;\n        if (self._ptr != needle._ptr) {\n            assembly {\n                let length := mload(needle)\n                let selfptr := mload(add(self, 0x20))\n                let needleptr := mload(add(needle, 0x20))\n                equal := eq(sha3(selfptr, length), sha3(needleptr, length))\n            }\n        }\n\n        if (equal) {\n            self._len -= needle._len;\n            self._ptr += needle._len;\n        }\n\n        return self;\n    }"
    ParameterList
       Source: "(slice self, slice needle)"
      VariableDeclaration "self"
         Type: struct strings.slice memory
         Source: "slice self"
        UserDefinedTypeName "slice"
           Source: "slice"
      VariableDeclaration "needle"
         Type: struct strings.slice memory
         Source: "slice needle"
        UserDefinedTypeName "slice"
           Source: "slice"
    ParameterList
       Source: "(slice)"
      VariableDeclaration ""
         Type: struct strings.slice memory
         Source: "slice"
        UserDefinedTypeName "slice"
           Source: "slice"
    Block
       Source: "{\n        if (self._len < needle._len) {\n            return self;\n        }\n\n        bool equal = true;\n        if (self._ptr != needle._ptr) {\n            assembly {\n                let length := mload(needle)\n                let selfptr := mload(add(self, 0x20))\n                let needleptr := mload(add(needle, 0x20))\n                equal := eq(sha3(selfptr, length), sha3(needleptr, length))\n            }\n        }\n\n        if (equal) {\n            self._len -= needle._len;\n            self._ptr += needle._len;\n        }\n\n        return self;\n    }"
      IfStatement
         Source: "if (self._len < needle._len) {\n            return self;\n        }"
        BinaryOperation using operator <
           Type: bool
           Source: "self._len < needle._len"
          MemberAccess to member _len
             Type: uint256
             Source: "self._len"
            Identifier self
               Type: struct strings.slice memory
               Source: "self"
          MemberAccess to member _len
             Type: uint256
             Source: "needle._len"
            Identifier needle
               Type: struct strings.slice memory
               Source: "needle"
        Block
           Source: "{\n            return self;\n        }"
          Return
             Source: "return self"
            Identifier self
               Type: struct strings.slice memory
               Source: "self"
      VariableDeclarationStatement
         Source: "bool equal = true"
        VariableDeclaration "equal"
           Type: bool
           Source: "bool equal"
          ElementaryTypeName bool
             Source: "bool"
        Literal, token: true value: true
           Type: bool
           Source: "true"
      IfStatement
         Source: "if (self._ptr != needle._ptr) {\n            assembly {\n                let length := mload(needle)\n                let selfptr := mload(add(self, 0x20))\n                let needleptr := mload(add(needle, 0x20))\n                equal := eq(sha3(selfptr, length), sha3(needleptr, length))\n            }\n        }"
        BinaryOperation using operator !=
           Type: bool
           Source: "self._ptr != needle._ptr"
          MemberAccess to member _ptr
             Type: uint256
             Source: "self._ptr"
            Identifier self
               Type: struct strings.slice memory
               Source: "self"
          MemberAccess to member _ptr
             Type: uint256
             Source: "needle._ptr"
            Identifier needle
               Type: struct strings.slice memory
               Source: "needle"
        Block
           Source: "{\n            assembly {\n                let length := mload(needle)\n                let selfptr := mload(add(self, 0x20))\n                let needleptr := mload(add(needle, 0x20))\n                equal := eq(sha3(selfptr, length), sha3(needleptr, length))\n            }\n        }"
          InlineAssembly
             Source: "assembly {\n                let length := mload(needle)\n                let selfptr := mload(add(self, 0x20))\n                let needleptr := mload(add(needle, 0x20))\n                equal := eq(sha3(selfptr, length), sha3(needleptr, length))\n            }\n        }"
      IfStatement
         Source: "if (equal) {\n            self._len -= needle._len;\n            self._ptr += needle._len;\n        }"
        Identifier equal
           Type: bool
           Source: "equal"
        Block
           Source: "{\n            self._len -= needle._len;\n            self._ptr += needle._len;\n        }"
          ExpressionStatement
             Source: "self._len -= needle._len"
            Assignment using operator -=
               Type: uint256
               Source: "self._len -= needle._len"
              MemberAccess to member _len
                 Type: uint256
                 Source: "self._len"
                Identifier self
                   Type: struct strings.slice memory
                   Source: "self"
              MemberAccess to member _len
                 Type: uint256
                 Source: "needle._len"
                Identifier needle
                   Type: struct strings.slice memory
                   Source: "needle"
          ExpressionStatement
             Source: "self._ptr += needle._len"
            Assignment using operator +=
               Type: uint256
               Source: "self._ptr += needle._len"
              MemberAccess to member _ptr
                 Type: uint256
                 Source: "self._ptr"
                Identifier self
                   Type: struct strings.slice memory
                   Source: "self"
              MemberAccess to member _len
                 Type: uint256
                 Source: "needle._len"
                Identifier needle
                   Type: struct strings.slice memory
                   Source: "needle"
      Return
         Source: "return self"
        Identifier self
           Type: struct strings.slice memory
           Source: "self"
  FunctionDefinition "endsWith"
     Source: "function endsWith(slice self, slice needle) internal returns (bool) {\n        if (self._len < needle._len) {\n            return false;\n        }\n\n        var selfptr = self._ptr + self._len - needle._len;\n\n        if (selfptr == needle._ptr) {\n            return true;\n        }\n\n        bool equal;\n        assembly {\n            let length := mload(needle)\n            let needleptr := mload(add(needle, 0x20))\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n        }\n\n        return equal;\n    }"
    ParameterList
       Source: "(slice self, slice needle)"
      VariableDeclaration "self"
         Type: struct strings.slice memory
         Source: "slice self"
        UserDefinedTypeName "slice"
           Source: "slice"
      VariableDeclaration "needle"
         Type: struct strings.slice memory
         Source: "slice needle"
        UserDefinedTypeName "slice"
           Source: "slice"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\n        if (self._len < needle._len) {\n            return false;\n        }\n\n        var selfptr = self._ptr + self._len - needle._len;\n\n        if (selfptr == needle._ptr) {\n            return true;\n        }\n\n        bool equal;\n        assembly {\n            let length := mload(needle)\n            let needleptr := mload(add(needle, 0x20))\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n        }\n\n        return equal;\n    }"
      IfStatement
         Source: "if (self._len < needle._len) {\n            return false;\n        }"
        BinaryOperation using operator <
           Type: bool
           Source: "self._len < needle._len"
          MemberAccess to member _len
             Type: uint256
             Source: "self._len"
            Identifier self
               Type: struct strings.slice memory
               Source: "self"
          MemberAccess to member _len
             Type: uint256
             Source: "needle._len"
            Identifier needle
               Type: struct strings.slice memory
               Source: "needle"
        Block
           Source: "{\n            return false;\n        }"
          Return
             Source: "return false"
            Literal, token: false value: false
               Type: bool
               Source: "false"
      VariableDeclarationStatement
         Source: "var selfptr = self._ptr + self._len - needle._len"
        VariableDeclaration "selfptr"
           Type: uint256
           Source: "var selfptr"
        BinaryOperation using operator -
           Type: uint256
           Source: "self._ptr + self._len - needle._len"
          BinaryOperation using operator +
             Type: uint256
             Source: "self._ptr + self._len"
            MemberAccess to member _ptr
               Type: uint256
               Source: "self._ptr"
              Identifier self
                 Type: struct strings.slice memory
                 Source: "self"
            MemberAccess to member _len
               Type: uint256
               Source: "self._len"
              Identifier self
                 Type: struct strings.slice memory
                 Source: "self"
          MemberAccess to member _len
             Type: uint256
             Source: "needle._len"
            Identifier needle
               Type: struct strings.slice memory
               Source: "needle"
      IfStatement
         Source: "if (selfptr == needle._ptr) {\n            return true;\n        }"
        BinaryOperation using operator ==
           Type: bool
           Source: "selfptr == needle._ptr"
          Identifier selfptr
             Type: uint256
             Source: "selfptr"
          MemberAccess to member _ptr
             Type: uint256
             Source: "needle._ptr"
            Identifier needle
               Type: struct strings.slice memory
               Source: "needle"
        Block
           Source: "{\n            return true;\n        }"
          Return
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
      VariableDeclarationStatement
         Source: "bool equal"
        VariableDeclaration "equal"
           Type: bool
           Source: "bool equal"
          ElementaryTypeName bool
             Source: "bool"
      InlineAssembly
         Source: "assembly {\n            let length := mload(needle)\n            let needleptr := mload(add(needle, 0x20))\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n        }\n\n        return"
      Return
         Source: "return equal"
        Identifier equal
           Type: bool
           Source: "equal"
  FunctionDefinition "until"
     Source: "function until(slice self, slice needle) internal returns (slice) {\n        if (self._len < needle._len) {\n            return self;\n        }\n\n        var selfptr = self._ptr + self._len - needle._len;\n        bool equal = true;\n        if (selfptr != needle._ptr) {\n            assembly {\n                let length := mload(needle)\n                let needleptr := mload(add(needle, 0x20))\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n            }\n        }\n\n        if (equal) {\n            self._len -= needle._len;\n        }\n\n        return self;\n    }"
    ParameterList
       Source: "(slice self, slice needle)"
      VariableDeclaration "self"
         Type: struct strings.slice memory
         Source: "slice self"
        UserDefinedTypeName "slice"
           Source: "slice"
      VariableDeclaration "needle"
         Type: struct strings.slice memory
         Source: "slice needle"
        UserDefinedTypeName "slice"
           Source: "slice"
    ParameterList
       Source: "(slice)"
      VariableDeclaration ""
         Type: struct strings.slice memory
         Source: "slice"
        UserDefinedTypeName "slice"
           Source: "slice"
    Block
       Source: "{\n        if (self._len < needle._len) {\n            return self;\n        }\n\n        var selfptr = self._ptr + self._len - needle._len;\n        bool equal = true;\n        if (selfptr != needle._ptr) {\n            assembly {\n                let length := mload(needle)\n                let needleptr := mload(add(needle, 0x20))\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n            }\n        }\n\n        if (equal) {\n            self._len -= needle._len;\n        }\n\n        return self;\n    }"
      IfStatement
         Source: "if (self._len < needle._len) {\n            return self;\n        }"
        BinaryOperation using operator <
           Type: bool
           Source: "self._len < needle._len"
          MemberAccess to member _len
             Type: uint256
             Source: "self._len"
            Identifier self
               Type: struct strings.slice memory
               Source: "self"
          MemberAccess to member _len
             Type: uint256
             Source: "needle._len"
            Identifier needle
               Type: struct strings.slice memory
               Source: "needle"
        Block
           Source: "{\n            return self;\n        }"
          Return
             Source: "return self"
            Identifier self
               Type: struct strings.slice memory
               Source: "self"
      VariableDeclarationStatement
         Source: "var selfptr = self._ptr + self._len - needle._len"
        VariableDeclaration "selfptr"
           Type: uint256
           Source: "var selfptr"
        BinaryOperation using operator -
           Type: uint256
           Source: "self._ptr + self._len - needle._len"
          BinaryOperation using operator +
             Type: uint256
             Source: "self._ptr + self._len"
            MemberAccess to member _ptr
               Type: uint256
               Source: "self._ptr"
              Identifier self
                 Type: struct strings.slice memory
                 Source: "self"
            MemberAccess to member _len
               Type: uint256
               Source: "self._len"
              Identifier self
                 Type: struct strings.slice memory
                 Source: "self"
          MemberAccess to member _len
             Type: uint256
             Source: "needle._len"
            Identifier needle
               Type: struct strings.slice memory
               Source: "needle"
      VariableDeclarationStatement
         Source: "bool equal = true"
        VariableDeclaration "equal"
           Type: bool
           Source: "bool equal"
          ElementaryTypeName bool
             Source: "bool"
        Literal, token: true value: true
           Type: bool
           Source: "true"
      IfStatement
         Source: "if (selfptr != needle._ptr) {\n            assembly {\n                let length := mload(needle)\n                let needleptr := mload(add(needle, 0x20))\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n            }\n        }"
        BinaryOperation using operator !=
           Type: bool
           Source: "selfptr != needle._ptr"
          Identifier selfptr
             Type: uint256
             Source: "selfptr"
          MemberAccess to member _ptr
             Type: uint256
             Source: "needle._ptr"
            Identifier needle
               Type: struct strings.slice memory
               Source: "needle"
        Block
           Source: "{\n            assembly {\n                let length := mload(needle)\n                let needleptr := mload(add(needle, 0x20))\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n            }\n        }"
          InlineAssembly
             Source: "assembly {\n                let length := mload(needle)\n                let needleptr := mload(add(needle, 0x20))\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n            }\n        }"
      IfStatement
         Source: "if (equal) {\n            self._len -= needle._len;\n        }"
        Identifier equal
           Type: bool
           Source: "equal"
        Block
           Source: "{\n            self._len -= needle._len;\n        }"
          ExpressionStatement
             Source: "self._len -= needle._len"
            Assignment using operator -=
               Type: uint256
               Source: "self._len -= needle._len"
              MemberAccess to member _len
                 Type: uint256
                 Source: "self._len"
                Identifier self
                   Type: struct strings.slice memory
                   Source: "self"
              MemberAccess to member _len
                 Type: uint256
                 Source: "needle._len"
                Identifier needle
                   Type: struct strings.slice memory
                   Source: "needle"
      Return
         Source: "return self"
        Identifier self
           Type: struct strings.slice memory
           Source: "self"
  FunctionDefinition "findPtr"
     Source: "function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private returns (uint) {\n        uint ptr;\n        uint idx;\n\n        if (needlelen <= selflen) {\n            if (needlelen <= 32) {\n                // Optimized assembly for 68 gas per byte on short strings\n                assembly {\n                    let mask := not(sub(exp(2, mul(8, sub(32, needlelen))), 1))\n                    let needledata := and(mload(needleptr), mask)\n                    let end := add(selfptr, sub(selflen, needlelen))\n                    ptr := selfptr\n                    loop:\n                    jumpi(exit, eq(and(mload(ptr), mask), needledata))\n                    ptr := add(ptr, 1)\n                    jumpi(loop, lt(sub(ptr, 1), end))\n                    ptr := add(selfptr, selflen)\n                    exit:\n                }\n                return ptr;\n            } else {\n                // For long needles, use hashing\n                bytes32 hash;\n                assembly { hash := sha3(needleptr, needlelen) }\n                ptr = selfptr;\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\n                    bytes32 testHash;\n                    assembly { testHash := sha3(ptr, needlelen) }\n                    if (hash == testHash)\n                        return ptr;\n                    ptr += 1;\n                }\n            }\n        }\n        return selfptr + selflen;\n    }"
    ParameterList
       Source: "(uint selflen, uint selfptr, uint needlelen, uint needleptr)"
      VariableDeclaration "selflen"
         Type: uint256
         Source: "uint selflen"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "selfptr"
         Type: uint256
         Source: "uint selfptr"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "needlelen"
         Type: uint256
         Source: "uint needlelen"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "needleptr"
         Type: uint256
         Source: "uint needleptr"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\n        uint ptr;\n        uint idx;\n\n        if (needlelen <= selflen) {\n            if (needlelen <= 32) {\n                // Optimized assembly for 68 gas per byte on short strings\n                assembly {\n                    let mask := not(sub(exp(2, mul(8, sub(32, needlelen))), 1))\n                    let needledata := and(mload(needleptr), mask)\n                    let end := add(selfptr, sub(selflen, needlelen))\n                    ptr := selfptr\n                    loop:\n                    jumpi(exit, eq(and(mload(ptr), mask), needledata))\n                    ptr := add(ptr, 1)\n                    jumpi(loop, lt(sub(ptr, 1), end))\n                    ptr := add(selfptr, selflen)\n                    exit:\n                }\n                return ptr;\n            } else {\n                // For long needles, use hashing\n                bytes32 hash;\n                assembly { hash := sha3(needleptr, needlelen) }\n                ptr = selfptr;\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\n                    bytes32 testHash;\n                    assembly { testHash := sha3(ptr, needlelen) }\n                    if (hash == testHash)\n                        return ptr;\n                    ptr += 1;\n                }\n            }\n        }\n        return selfptr + selflen;\n    }"
      VariableDeclarationStatement
         Source: "uint ptr"
        VariableDeclaration "ptr"
           Type: uint256
           Source: "uint ptr"
          ElementaryTypeName uint
             Source: "uint"
      VariableDeclarationStatement
         Source: "uint idx"
        VariableDeclaration "idx"
           Type: uint256
           Source: "uint idx"
          ElementaryTypeName uint
             Source: "uint"
      IfStatement
         Source: "if (needlelen <= selflen) {\n            if (needlelen <= 32) {\n                // Optimized assembly for 68 gas per byte on short strings\n                assembly {\n                    let mask := not(sub(exp(2, mul(8, sub(32, needlelen))), 1))\n                    let needledata := and(mload(needleptr), mask)\n                    let end := add(selfptr, sub(selflen, needlelen))\n                    ptr := selfptr\n                    loop:\n                    jumpi(exit, eq(and(mload(ptr), mask), needledata))\n                    ptr := add(ptr, 1)\n                    jumpi(loop, lt(sub(ptr, 1), end))\n                    ptr := add(selfptr, selflen)\n                    exit:\n                }\n                return ptr;\n            } else {\n                // For long needles, use hashing\n                bytes32 hash;\n                assembly { hash := sha3(needleptr, needlelen) }\n                ptr = selfptr;\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\n                    bytes32 testHash;\n                    assembly { testHash := sha3(ptr, needlelen) }\n                    if (hash == testHash)\n                        return ptr;\n                    ptr += 1;\n                }\n            }\n        }"
        BinaryOperation using operator <=
           Type: bool
           Source: "needlelen <= selflen"
          Identifier needlelen
             Type: uint256
             Source: "needlelen"
          Identifier selflen
             Type: uint256
             Source: "selflen"
        Block
           Source: "{\n            if (needlelen <= 32) {\n                // Optimized assembly for 68 gas per byte on short strings\n                assembly {\n                    let mask := not(sub(exp(2, mul(8, sub(32, needlelen))), 1))\n                    let needledata := and(mload(needleptr), mask)\n                    let end := add(selfptr, sub(selflen, needlelen))\n                    ptr := selfptr\n                    loop:\n                    jumpi(exit, eq(and(mload(ptr), mask), needledata))\n                    ptr := add(ptr, 1)\n                    jumpi(loop, lt(sub(ptr, 1), end))\n                    ptr := add(selfptr, selflen)\n                    exit:\n                }\n                return ptr;\n            } else {\n                // For long needles, use hashing\n                bytes32 hash;\n                assembly { hash := sha3(needleptr, needlelen) }\n                ptr = selfptr;\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\n                    bytes32 testHash;\n                    assembly { testHash := sha3(ptr, needlelen) }\n                    if (hash == testHash)\n                        return ptr;\n                    ptr += 1;\n                }\n            }\n        }"
          IfStatement
             Source: "if (needlelen <= 32) {\n                // Optimized assembly for 68 gas per byte on short strings\n                assembly {\n                    let mask := not(sub(exp(2, mul(8, sub(32, needlelen))), 1))\n                    let needledata := and(mload(needleptr), mask)\n                    let end := add(selfptr, sub(selflen, needlelen))\n                    ptr := selfptr\n                    loop:\n                    jumpi(exit, eq(and(mload(ptr), mask), needledata))\n                    ptr := add(ptr, 1)\n                    jumpi(loop, lt(sub(ptr, 1), end))\n                    ptr := add(selfptr, selflen)\n                    exit:\n                }\n                return ptr;\n            } else {\n                // For long needles, use hashing\n                bytes32 hash;\n                assembly { hash := sha3(needleptr, needlelen) }\n                ptr = selfptr;\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\n                    bytes32 testHash;\n                    assembly { testHash := sha3(ptr, needlelen) }\n                    if (hash == testHash)\n                        return ptr;\n                    ptr += 1;\n                }\n            }"
            BinaryOperation using operator <=
               Type: bool
               Source: "needlelen <= 32"
              Identifier needlelen
                 Type: uint256
                 Source: "needlelen"
              Literal, token: [no token] value: 32
                 Type: int_const 32
                 Source: "32"
            Block
               Source: "{\n                // Optimized assembly for 68 gas per byte on short strings\n                assembly {\n                    let mask := not(sub(exp(2, mul(8, sub(32, needlelen))), 1))\n                    let needledata := and(mload(needleptr), mask)\n                    let end := add(selfptr, sub(selflen, needlelen))\n                    ptr := selfptr\n                    loop:\n                    jumpi(exit, eq(and(mload(ptr), mask), needledata))\n                    ptr := add(ptr, 1)\n                    jumpi(loop, lt(sub(ptr, 1), end))\n                    ptr := add(selfptr, selflen)\n                    exit:\n                }\n                return ptr;\n            }"
              InlineAssembly
                 Source: "assembly {\n                    let mask := not(sub(exp(2, mul(8, sub(32, needlelen))), 1))\n                    let needledata := and(mload(needleptr), mask)\n                    let end := add(selfptr, sub(selflen, needlelen))\n                    ptr := selfptr\n                    loop:\n                    jumpi(exit, eq(and(mload(ptr), mask), needledata))\n                    ptr := add(ptr, 1)\n                    jumpi(loop, lt(sub(ptr, 1), end))\n                    ptr := add(selfptr, selflen)\n                    exit:\n                }\n                return"
              Return
                 Source: "return ptr"
                Identifier ptr
                   Type: uint256
                   Source: "ptr"
            Block
               Source: "{\n                // For long needles, use hashing\n                bytes32 hash;\n                assembly { hash := sha3(needleptr, needlelen) }\n                ptr = selfptr;\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\n                    bytes32 testHash;\n                    assembly { testHash := sha3(ptr, needlelen) }\n                    if (hash == testHash)\n                        return ptr;\n                    ptr += 1;\n                }\n            }"
              VariableDeclarationStatement
                 Source: "bytes32 hash"
                VariableDeclaration "hash"
                   Type: bytes32
                   Source: "bytes32 hash"
                  ElementaryTypeName bytes32
                     Source: "bytes32"
              InlineAssembly
                 Source: "assembly { hash := sha3(needleptr, needlelen) }\n                ptr"
              ExpressionStatement
                 Source: "ptr = selfptr"
                Assignment using operator =
                   Type: uint256
                   Source: "ptr = selfptr"
                  Identifier ptr
                     Type: uint256
                     Source: "ptr"
                  Identifier selfptr
                     Type: uint256
                     Source: "selfptr"
              ForStatement
                 Source: "for (idx = 0; idx <= selflen - needlelen; idx++) {\n                    bytes32 testHash;\n                    assembly { testHash := sha3(ptr, needlelen) }\n                    if (hash == testHash)\n                        return ptr;\n                    ptr += 1;\n                }"
                ExpressionStatement
                   Source: "idx = 0"
                  Assignment using operator =
                     Type: uint256
                     Source: "idx = 0"
                    Identifier idx
                       Type: uint256
                       Source: "idx"
                    Literal, token: [no token] value: 0
                       Type: int_const 0
                       Source: "0"
                BinaryOperation using operator <=
                   Type: bool
                   Source: "idx <= selflen - needlelen"
                  Identifier idx
                     Type: uint256
                     Source: "idx"
                  BinaryOperation using operator -
                     Type: uint256
                     Source: "selflen - needlelen"
                    Identifier selflen
                       Type: uint256
                       Source: "selflen"
                    Identifier needlelen
                       Type: uint256
                       Source: "needlelen"
                ExpressionStatement
                   Source: "idx++"
                  UnaryOperation (postfix) ++
                     Type: uint256
                     Source: "idx++"
                    Identifier idx
                       Type: uint256
                       Source: "idx"
                Block
                   Source: "{\n                    bytes32 testHash;\n                    assembly { testHash := sha3(ptr, needlelen) }\n                    if (hash == testHash)\n                        return ptr;\n                    ptr += 1;\n                }"
                  VariableDeclarationStatement
                     Source: "bytes32 testHash"
                    VariableDeclaration "testHash"
                       Type: bytes32
                       Source: "bytes32 testHash"
                      ElementaryTypeName bytes32
                         Source: "bytes32"
                  InlineAssembly
                     Source: "assembly { testHash := sha3(ptr, needlelen) }\n                    if"
                  IfStatement
                     Source: "if (hash == testHash)\n                        return ptr"
                    BinaryOperation using operator ==
                       Type: bool
                       Source: "hash == testHash"
                      Identifier hash
                         Type: bytes32
                         Source: "hash"
                      Identifier testHash
                         Type: bytes32
                         Source: "testHash"
                    Return
                       Source: "return ptr"
                      Identifier ptr
                         Type: uint256
                         Source: "ptr"
                  ExpressionStatement
                     Source: "ptr += 1"
                    Assignment using operator +=
                       Type: uint256
                       Source: "ptr += 1"
                      Identifier ptr
                         Type: uint256
                         Source: "ptr"
                      Literal, token: [no token] value: 1
                         Type: int_const 1
                         Source: "1"
      Return
         Source: "return selfptr + selflen"
        BinaryOperation using operator +
           Type: uint256
           Source: "selfptr + selflen"
          Identifier selfptr
             Type: uint256
             Source: "selfptr"
          Identifier selflen
             Type: uint256
             Source: "selflen"
  FunctionDefinition "rfindPtr"
     Source: "function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private returns (uint) {\n        uint ptr;\n\n        if (needlelen <= selflen) {\n            if (needlelen <= 32) {\n                // Optimized assembly for 69 gas per byte on short strings\n                assembly {\n                    let mask := not(sub(exp(2, mul(8, sub(32, needlelen))), 1))\n                    let needledata := and(mload(needleptr), mask)\n                    ptr := add(selfptr, sub(selflen, needlelen))\n                    loop:\n                    jumpi(ret, eq(and(mload(ptr), mask), needledata))\n                    ptr := sub(ptr, 1)\n                    jumpi(loop, gt(add(ptr, 1), selfptr))\n                    ptr := selfptr\n                    jump(exit)\n                    ret:\n                    ptr := add(ptr, needlelen)\n                    exit:\n                }\n                return ptr;\n            } else {\n                // For long needles, use hashing\n                bytes32 hash;\n                assembly { hash := sha3(needleptr, needlelen) }\n                ptr = selfptr + (selflen - needlelen);\n                while (ptr >= selfptr) {\n                    bytes32 testHash;\n                    assembly { testHash := sha3(ptr, needlelen) }\n                    if (hash == testHash)\n                        return ptr + needlelen;\n                    ptr -= 1;\n                }\n            }\n        }\n        return selfptr;\n    }"
    ParameterList
       Source: "(uint selflen, uint selfptr, uint needlelen, uint needleptr)"
      VariableDeclaration "selflen"
         Type: uint256
         Source: "uint selflen"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "selfptr"
         Type: uint256
         Source: "uint selfptr"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "needlelen"
         Type: uint256
         Source: "uint needlelen"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "needleptr"
         Type: uint256
         Source: "uint needleptr"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\n        uint ptr;\n\n        if (needlelen <= selflen) {\n            if (needlelen <= 32) {\n                // Optimized assembly for 69 gas per byte on short strings\n                assembly {\n                    let mask := not(sub(exp(2, mul(8, sub(32, needlelen))), 1))\n                    let needledata := and(mload(needleptr), mask)\n                    ptr := add(selfptr, sub(selflen, needlelen))\n                    loop:\n                    jumpi(ret, eq(and(mload(ptr), mask), needledata))\n                    ptr := sub(ptr, 1)\n                    jumpi(loop, gt(add(ptr, 1), selfptr))\n                    ptr := selfptr\n                    jump(exit)\n                    ret:\n                    ptr := add(ptr, needlelen)\n                    exit:\n                }\n                return ptr;\n            } else {\n                // For long needles, use hashing\n                bytes32 hash;\n                assembly { hash := sha3(needleptr, needlelen) }\n                ptr = selfptr + (selflen - needlelen);\n                while (ptr >= selfptr) {\n                    bytes32 testHash;\n                    assembly { testHash := sha3(ptr, needlelen) }\n                    if (hash == testHash)\n                        return ptr + needlelen;\n                    ptr -= 1;\n                }\n            }\n        }\n        return selfptr;\n    }"
      VariableDeclarationStatement
         Source: "uint ptr"
        VariableDeclaration "ptr"
           Type: uint256
           Source: "uint ptr"
          ElementaryTypeName uint
             Source: "uint"
      IfStatement
         Source: "if (needlelen <= selflen) {\n            if (needlelen <= 32) {\n                // Optimized assembly for 69 gas per byte on short strings\n                assembly {\n                    let mask := not(sub(exp(2, mul(8, sub(32, needlelen))), 1))\n                    let needledata := and(mload(needleptr), mask)\n                    ptr := add(selfptr, sub(selflen, needlelen))\n                    loop:\n                    jumpi(ret, eq(and(mload(ptr), mask), needledata))\n                    ptr := sub(ptr, 1)\n                    jumpi(loop, gt(add(ptr, 1), selfptr))\n                    ptr := selfptr\n                    jump(exit)\n                    ret:\n                    ptr := add(ptr, needlelen)\n                    exit:\n                }\n                return ptr;\n            } else {\n                // For long needles, use hashing\n                bytes32 hash;\n                assembly { hash := sha3(needleptr, needlelen) }\n                ptr = selfptr + (selflen - needlelen);\n                while (ptr >= selfptr) {\n                    bytes32 testHash;\n                    assembly { testHash := sha3(ptr, needlelen) }\n                    if (hash == testHash)\n                        return ptr + needlelen;\n                    ptr -= 1;\n                }\n            }\n        }"
        BinaryOperation using operator <=
           Type: bool
           Source: "needlelen <= selflen"
          Identifier needlelen
             Type: uint256
             Source: "needlelen"
          Identifier selflen
             Type: uint256
             Source: "selflen"
        Block
           Source: "{\n            if (needlelen <= 32) {\n                // Optimized assembly for 69 gas per byte on short strings\n                assembly {\n                    let mask := not(sub(exp(2, mul(8, sub(32, needlelen))), 1))\n                    let needledata := and(mload(needleptr), mask)\n                    ptr := add(selfptr, sub(selflen, needlelen))\n                    loop:\n                    jumpi(ret, eq(and(mload(ptr), mask), needledata))\n                    ptr := sub(ptr, 1)\n                    jumpi(loop, gt(add(ptr, 1), selfptr))\n                    ptr := selfptr\n                    jump(exit)\n                    ret:\n                    ptr := add(ptr, needlelen)\n                    exit:\n                }\n                return ptr;\n            } else {\n                // For long needles, use hashing\n                bytes32 hash;\n                assembly { hash := sha3(needleptr, needlelen) }\n                ptr = selfptr + (selflen - needlelen);\n                while (ptr >= selfptr) {\n                    bytes32 testHash;\n                    assembly { testHash := sha3(ptr, needlelen) }\n                    if (hash == testHash)\n                        return ptr + needlelen;\n                    ptr -= 1;\n                }\n            }\n        }"
          IfStatement
             Source: "if (needlelen <= 32) {\n                // Optimized assembly for 69 gas per byte on short strings\n                assembly {\n                    let mask := not(sub(exp(2, mul(8, sub(32, needlelen))), 1))\n                    let needledata := and(mload(needleptr), mask)\n                    ptr := add(selfptr, sub(selflen, needlelen))\n                    loop:\n                    jumpi(ret, eq(and(mload(ptr), mask), needledata))\n                    ptr := sub(ptr, 1)\n                    jumpi(loop, gt(add(ptr, 1), selfptr))\n                    ptr := selfptr\n                    jump(exit)\n                    ret:\n                    ptr := add(ptr, needlelen)\n                    exit:\n                }\n                return ptr;\n            } else {\n                // For long needles, use hashing\n                bytes32 hash;\n                assembly { hash := sha3(needleptr, needlelen) }\n                ptr = selfptr + (selflen - needlelen);\n                while (ptr >= selfptr) {\n                    bytes32 testHash;\n                    assembly { testHash := sha3(ptr, needlelen) }\n                    if (hash == testHash)\n                        return ptr + needlelen;\n                    ptr -= 1;\n                }\n            }"
            BinaryOperation using operator <=
               Type: bool
               Source: "needlelen <= 32"
              Identifier needlelen
                 Type: uint256
                 Source: "needlelen"
              Literal, token: [no token] value: 32
                 Type: int_const 32
                 Source: "32"
            Block
               Source: "{\n                // Optimized assembly for 69 gas per byte on short strings\n                assembly {\n                    let mask := not(sub(exp(2, mul(8, sub(32, needlelen))), 1))\n                    let needledata := and(mload(needleptr), mask)\n                    ptr := add(selfptr, sub(selflen, needlelen))\n                    loop:\n                    jumpi(ret, eq(and(mload(ptr), mask), needledata))\n                    ptr := sub(ptr, 1)\n                    jumpi(loop, gt(add(ptr, 1), selfptr))\n                    ptr := selfptr\n                    jump(exit)\n                    ret:\n                    ptr := add(ptr, needlelen)\n                    exit:\n                }\n                return ptr;\n            }"
              InlineAssembly
                 Source: "assembly {\n                    let mask := not(sub(exp(2, mul(8, sub(32, needlelen))), 1))\n                    let needledata := and(mload(needleptr), mask)\n                    ptr := add(selfptr, sub(selflen, needlelen))\n                    loop:\n                    jumpi(ret, eq(and(mload(ptr), mask), needledata))\n                    ptr := sub(ptr, 1)\n                    jumpi(loop, gt(add(ptr, 1), selfptr))\n                    ptr := selfptr\n                    jump(exit)\n                    ret:\n                    ptr := add(ptr, needlelen)\n                    exit:\n                }\n                return"
              Return
                 Source: "return ptr"
                Identifier ptr
                   Type: uint256
                   Source: "ptr"
            Block
               Source: "{\n                // For long needles, use hashing\n                bytes32 hash;\n                assembly { hash := sha3(needleptr, needlelen) }\n                ptr = selfptr + (selflen - needlelen);\n                while (ptr >= selfptr) {\n                    bytes32 testHash;\n                    assembly { testHash := sha3(ptr, needlelen) }\n                    if (hash == testHash)\n                        return ptr + needlelen;\n                    ptr -= 1;\n                }\n            }"
              VariableDeclarationStatement
                 Source: "bytes32 hash"
                VariableDeclaration "hash"
                   Type: bytes32
                   Source: "bytes32 hash"
                  ElementaryTypeName bytes32
                     Source: "bytes32"
              InlineAssembly
                 Source: "assembly { hash := sha3(needleptr, needlelen) }\n                ptr"
              ExpressionStatement
                 Source: "ptr = selfptr + (selflen - needlelen)"
                Assignment using operator =
                   Type: uint256
                   Source: "ptr = selfptr + (selflen - needlelen)"
                  Identifier ptr
                     Type: uint256
                     Source: "ptr"
                  BinaryOperation using operator +
                     Type: uint256
                     Source: "selfptr + (selflen - needlelen)"
                    Identifier selfptr
                       Type: uint256
                       Source: "selfptr"
                    TupleExpression
                       Type: uint256
                       Source: "(selflen - needlelen)"
                      BinaryOperation using operator -
                         Type: uint256
                         Source: "selflen - needlelen"
                        Identifier selflen
                           Type: uint256
                           Source: "selflen"
                        Identifier needlelen
                           Type: uint256
                           Source: "needlelen"
              WhileStatement
                 Source: "while (ptr >= selfptr) {\n                    bytes32 testHash;\n                    assembly { testHash := sha3(ptr, needlelen) }\n                    if (hash == testHash)\n                        return ptr + needlelen;\n                    ptr -= 1;\n                }"
                BinaryOperation using operator >=
                   Type: bool
                   Source: "ptr >= selfptr"
                  Identifier ptr
                     Type: uint256
                     Source: "ptr"
                  Identifier selfptr
                     Type: uint256
                     Source: "selfptr"
                Block
                   Source: "{\n                    bytes32 testHash;\n                    assembly { testHash := sha3(ptr, needlelen) }\n                    if (hash == testHash)\n                        return ptr + needlelen;\n                    ptr -= 1;\n                }"
                  VariableDeclarationStatement
                     Source: "bytes32 testHash"
                    VariableDeclaration "testHash"
                       Type: bytes32
                       Source: "bytes32 testHash"
                      ElementaryTypeName bytes32
                         Source: "bytes32"
                  InlineAssembly
                     Source: "assembly { testHash := sha3(ptr, needlelen) }\n                    if"
                  IfStatement
                     Source: "if (hash == testHash)\n                        return ptr + needlelen"
                    BinaryOperation using operator ==
                       Type: bool
                       Source: "hash == testHash"
                      Identifier hash
                         Type: bytes32
                         Source: "hash"
                      Identifier testHash
                         Type: bytes32
                         Source: "testHash"
                    Return
                       Source: "return ptr + needlelen"
                      BinaryOperation using operator +
                         Type: uint256
                         Source: "ptr + needlelen"
                        Identifier ptr
                           Type: uint256
                           Source: "ptr"
                        Identifier needlelen
                           Type: uint256
                           Source: "needlelen"
                  ExpressionStatement
                     Source: "ptr -= 1"
                    Assignment using operator -=
                       Type: uint256
                       Source: "ptr -= 1"
                      Identifier ptr
                         Type: uint256
                         Source: "ptr"
                      Literal, token: [no token] value: 1
                         Type: int_const 1
                         Source: "1"
      Return
         Source: "return selfptr"
        Identifier selfptr
           Type: uint256
           Source: "selfptr"
  FunctionDefinition "find"
     Source: "function find(slice self, slice needle) internal returns (slice) {\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n        self._len -= ptr - self._ptr;\n        self._ptr = ptr;\n        return self;\n    }"
    ParameterList
       Source: "(slice self, slice needle)"
      VariableDeclaration "self"
         Type: struct strings.slice memory
         Source: "slice self"
        UserDefinedTypeName "slice"
           Source: "slice"
      VariableDeclaration "needle"
         Type: struct strings.slice memory
         Source: "slice needle"
        UserDefinedTypeName "slice"
           Source: "slice"
    ParameterList
       Source: "(slice)"
      VariableDeclaration ""
         Type: struct strings.slice memory
         Source: "slice"
        UserDefinedTypeName "slice"
           Source: "slice"
    Block
       Source: "{\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n        self._len -= ptr - self._ptr;\n        self._ptr = ptr;\n        return self;\n    }"
      VariableDeclarationStatement
         Source: "uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr)"
        VariableDeclaration "ptr"
           Type: uint256
           Source: "uint ptr"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "findPtr(self._len, self._ptr, needle._len, needle._ptr)"
          Identifier findPtr
             Type: function (uint256,uint256,uint256,uint256) returns (uint256)
             Source: "findPtr"
          MemberAccess to member _len
             Type: uint256
             Source: "self._len"
            Identifier self
               Type: struct strings.slice memory
               Source: "self"
          MemberAccess to member _ptr
             Type: uint256
             Source: "self._ptr"
            Identifier self
               Type: struct strings.slice memory
               Source: "self"
          MemberAccess to member _len
             Type: uint256
             Source: "needle._len"
            Identifier needle
               Type: struct strings.slice memory
               Source: "needle"
          MemberAccess to member _ptr
             Type: uint256
             Source: "needle._ptr"
            Identifier needle
               Type: struct strings.slice memory
               Source: "needle"
      ExpressionStatement
         Source: "self._len -= ptr - self._ptr"
        Assignment using operator -=
           Type: uint256
           Source: "self._len -= ptr - self._ptr"
          MemberAccess to member _len
             Type: uint256
             Source: "self._len"
            Identifier self
               Type: struct strings.slice memory
               Source: "self"
          BinaryOperation using operator -
             Type: uint256
             Source: "ptr - self._ptr"
            Identifier ptr
               Type: uint256
               Source: "ptr"
            MemberAccess to member _ptr
               Type: uint256
               Source: "self._ptr"
              Identifier self
                 Type: struct strings.slice memory
                 Source: "self"
      ExpressionStatement
         Source: "self._ptr = ptr"
        Assignment using operator =
           Type: uint256
           Source: "self._ptr = ptr"
          MemberAccess to member _ptr
             Type: uint256
             Source: "self._ptr"
            Identifier self
               Type: struct strings.slice memory
               Source: "self"
          Identifier ptr
             Type: uint256
             Source: "ptr"
      Return
         Source: "return self"
        Identifier self
           Type: struct strings.slice memory
           Source: "self"
  FunctionDefinition "rfind"
     Source: "function rfind(slice self, slice needle) internal returns (slice) {\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n        self._len = ptr - self._ptr;\n        return self;\n    }"
    ParameterList
       Source: "(slice self, slice needle)"
      VariableDeclaration "self"
         Type: struct strings.slice memory
         Source: "slice self"
        UserDefinedTypeName "slice"
           Source: "slice"
      VariableDeclaration "needle"
         Type: struct strings.slice memory
         Source: "slice needle"
        UserDefinedTypeName "slice"
           Source: "slice"
    ParameterList
       Source: "(slice)"
      VariableDeclaration ""
         Type: struct strings.slice memory
         Source: "slice"
        UserDefinedTypeName "slice"
           Source: "slice"
    Block
       Source: "{\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n        self._len = ptr - self._ptr;\n        return self;\n    }"
      VariableDeclarationStatement
         Source: "uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr)"
        VariableDeclaration "ptr"
           Type: uint256
           Source: "uint ptr"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "rfindPtr(self._len, self._ptr, needle._len, needle._ptr)"
          Identifier rfindPtr
             Type: function (uint256,uint256,uint256,uint256) returns (uint256)
             Source: "rfindPtr"
          MemberAccess to member _len
             Type: uint256
             Source: "self._len"
            Identifier self
               Type: struct strings.slice memory
               Source: "self"
          MemberAccess to member _ptr
             Type: uint256
             Source: "self._ptr"
            Identifier self
               Type: struct strings.slice memory
               Source: "self"
          MemberAccess to member _len
             Type: uint256
             Source: "needle._len"
            Identifier needle
               Type: struct strings.slice memory
               Source: "needle"
          MemberAccess to member _ptr
             Type: uint256
             Source: "needle._ptr"
            Identifier needle
               Type: struct strings.slice memory
               Source: "needle"
      ExpressionStatement
         Source: "self._len = ptr - self._ptr"
        Assignment using operator =
           Type: uint256
           Source: "self._len = ptr - self._ptr"
          MemberAccess to member _len
             Type: uint256
             Source: "self._len"
            Identifier self
               Type: struct strings.slice memory
               Source: "self"
          BinaryOperation using operator -
             Type: uint256
             Source: "ptr - self._ptr"
            Identifier ptr
               Type: uint256
               Source: "ptr"
            MemberAccess to member _ptr
               Type: uint256
               Source: "self._ptr"
              Identifier self
                 Type: struct strings.slice memory
                 Source: "self"
      Return
         Source: "return self"
        Identifier self
           Type: struct strings.slice memory
           Source: "self"
  FunctionDefinition "split"
     Source: "function split(slice self, slice needle, slice token) internal returns (slice) {\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n        token._ptr = self._ptr;\n        token._len = ptr - self._ptr;\n        if (ptr == self._ptr + self._len) {\n            // Not found\n            self._len = 0;\n        } else {\n            self._len -= token._len + needle._len;\n            self._ptr = ptr + needle._len;\n        }\n        return token;\n    }"
    ParameterList
       Source: "(slice self, slice needle, slice token)"
      VariableDeclaration "self"
         Type: struct strings.slice memory
         Source: "slice self"
        UserDefinedTypeName "slice"
           Source: "slice"
      VariableDeclaration "needle"
         Type: struct strings.slice memory
         Source: "slice needle"
        UserDefinedTypeName "slice"
           Source: "slice"
      VariableDeclaration "token"
         Type: struct strings.slice memory
         Source: "slice token"
        UserDefinedTypeName "slice"
           Source: "slice"
    ParameterList
       Source: "(slice)"
      VariableDeclaration ""
         Type: struct strings.slice memory
         Source: "slice"
        UserDefinedTypeName "slice"
           Source: "slice"
    Block
       Source: "{\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n        token._ptr = self._ptr;\n        token._len = ptr - self._ptr;\n        if (ptr == self._ptr + self._len) {\n            // Not found\n            self._len = 0;\n        } else {\n            self._len -= token._len + needle._len;\n            self._ptr = ptr + needle._len;\n        }\n        return token;\n    }"
      VariableDeclarationStatement
         Source: "uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr)"
        VariableDeclaration "ptr"
           Type: uint256
           Source: "uint ptr"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "findPtr(self._len, self._ptr, needle._len, needle._ptr)"
          Identifier findPtr
             Type: function (uint256,uint256,uint256,uint256) returns (uint256)
             Source: "findPtr"
          MemberAccess to member _len
             Type: uint256
             Source: "self._len"
            Identifier self
               Type: struct strings.slice memory
               Source: "self"
          MemberAccess to member _ptr
             Type: uint256
             Source: "self._ptr"
            Identifier self
               Type: struct strings.slice memory
               Source: "self"
          MemberAccess to member _len
             Type: uint256
             Source: "needle._len"
            Identifier needle
               Type: struct strings.slice memory
               Source: "needle"
          MemberAccess to member _ptr
             Type: uint256
             Source: "needle._ptr"
            Identifier needle
               Type: struct strings.slice memory
               Source: "needle"
      ExpressionStatement
         Source: "token._ptr = self._ptr"
        Assignment using operator =
           Type: uint256
           Source: "token._ptr = self._ptr"
          MemberAccess to member _ptr
             Type: uint256
             Source: "token._ptr"
            Identifier token
               Type: struct strings.slice memory
               Source: "token"
          MemberAccess to member _ptr
             Type: uint256
             Source: "self._ptr"
            Identifier self
               Type: struct strings.slice memory
               Source: "self"
      ExpressionStatement
         Source: "token._len = ptr - self._ptr"
        Assignment using operator =
           Type: uint256
           Source: "token._len = ptr - self._ptr"
          MemberAccess to member _len
             Type: uint256
             Source: "token._len"
            Identifier token
               Type: struct strings.slice memory
               Source: "token"
          BinaryOperation using operator -
             Type: uint256
             Source: "ptr - self._ptr"
            Identifier ptr
               Type: uint256
               Source: "ptr"
            MemberAccess to member _ptr
               Type: uint256
               Source: "self._ptr"
              Identifier self
                 Type: struct strings.slice memory
                 Source: "self"
      IfStatement
         Source: "if (ptr == self._ptr + self._len) {\n            // Not found\n            self._len = 0;\n        } else {\n            self._len -= token._len + needle._len;\n            self._ptr = ptr + needle._len;\n        }"
        BinaryOperation using operator ==
           Type: bool
           Source: "ptr == self._ptr + self._len"
          Identifier ptr
             Type: uint256
             Source: "ptr"
          BinaryOperation using operator +
             Type: uint256
             Source: "self._ptr + self._len"
            MemberAccess to member _ptr
               Type: uint256
               Source: "self._ptr"
              Identifier self
                 Type: struct strings.slice memory
                 Source: "self"
            MemberAccess to member _len
               Type: uint256
               Source: "self._len"
              Identifier self
                 Type: struct strings.slice memory
                 Source: "self"
        Block
           Source: "{\n            // Not found\n            self._len = 0;\n        }"
          ExpressionStatement
             Source: "self._len = 0"
            Assignment using operator =
               Type: uint256
               Source: "self._len = 0"
              MemberAccess to member _len
                 Type: uint256
                 Source: "self._len"
                Identifier self
                   Type: struct strings.slice memory
                   Source: "self"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
        Block
           Source: "{\n            self._len -= token._len + needle._len;\n            self._ptr = ptr + needle._len;\n        }"
          ExpressionStatement
             Source: "self._len -= token._len + needle._len"
            Assignment using operator -=
               Type: uint256
               Source: "self._len -= token._len + needle._len"
              MemberAccess to member _len
                 Type: uint256
                 Source: "self._len"
                Identifier self
                   Type: struct strings.slice memory
                   Source: "self"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "token._len + needle._len"
                MemberAccess to member _len
                   Type: uint256
                   Source: "token._len"
                  Identifier token
                     Type: struct strings.slice memory
                     Source: "token"
                MemberAccess to member _len
                   Type: uint256
                   Source: "needle._len"
                  Identifier needle
                     Type: struct strings.slice memory
                     Source: "needle"
          ExpressionStatement
             Source: "self._ptr = ptr + needle._len"
            Assignment using operator =
               Type: uint256
               Source: "self._ptr = ptr + needle._len"
              MemberAccess to member _ptr
                 Type: uint256
                 Source: "self._ptr"
                Identifier self
                   Type: struct strings.slice memory
                   Source: "self"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "ptr + needle._len"
                Identifier ptr
                   Type: uint256
                   Source: "ptr"
                MemberAccess to member _len
                   Type: uint256
                   Source: "needle._len"
                  Identifier needle
                     Type: struct strings.slice memory
                     Source: "needle"
      Return
         Source: "return token"
        Identifier token
           Type: struct strings.slice memory
           Source: "token"
  FunctionDefinition "split"
     Source: "function split(slice self, slice needle) internal returns (slice token) {\n        split(self, needle, token);\n    }"
    ParameterList
       Source: "(slice self, slice needle)"
      VariableDeclaration "self"
         Type: struct strings.slice memory
         Source: "slice self"
        UserDefinedTypeName "slice"
           Source: "slice"
      VariableDeclaration "needle"
         Type: struct strings.slice memory
         Source: "slice needle"
        UserDefinedTypeName "slice"
           Source: "slice"
    ParameterList
       Source: "(slice token)"
      VariableDeclaration "token"
         Type: struct strings.slice memory
         Source: "slice token"
        UserDefinedTypeName "slice"
           Source: "slice"
    Block
       Source: "{\n        split(self, needle, token);\n    }"
      ExpressionStatement
         Source: "split(self, needle, token)"
        FunctionCall
           Type: struct strings.slice memory
           Source: "split(self, needle, token)"
          Identifier split
             Type: function (struct strings.slice memory,struct strings.slice memory,struct strings.slice memory) returns (struct strings.slice memory)
             Source: "split"
          Identifier self
             Type: struct strings.slice memory
             Source: "self"
          Identifier needle
             Type: struct strings.slice memory
             Source: "needle"
          Identifier token
             Type: struct strings.slice memory
             Source: "token"
  FunctionDefinition "rsplit"
     Source: "function rsplit(slice self, slice needle, slice token) internal returns (slice) {\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n        token._ptr = ptr;\n        token._len = self._len - (ptr - self._ptr);\n        if (ptr == self._ptr) {\n            // Not found\n            self._len = 0;\n        } else {\n            self._len -= token._len + needle._len;\n        }\n        return token;\n    }"
    ParameterList
       Source: "(slice self, slice needle, slice token)"
      VariableDeclaration "self"
         Type: struct strings.slice memory
         Source: "slice self"
        UserDefinedTypeName "slice"
           Source: "slice"
      VariableDeclaration "needle"
         Type: struct strings.slice memory
         Source: "slice needle"
        UserDefinedTypeName "slice"
           Source: "slice"
      VariableDeclaration "token"
         Type: struct strings.slice memory
         Source: "slice token"
        UserDefinedTypeName "slice"
           Source: "slice"
    ParameterList
       Source: "(slice)"
      VariableDeclaration ""
         Type: struct strings.slice memory
         Source: "slice"
        UserDefinedTypeName "slice"
           Source: "slice"
    Block
       Source: "{\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n        token._ptr = ptr;\n        token._len = self._len - (ptr - self._ptr);\n        if (ptr == self._ptr) {\n            // Not found\n            self._len = 0;\n        } else {\n            self._len -= token._len + needle._len;\n        }\n        return token;\n    }"
      VariableDeclarationStatement
         Source: "uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr)"
        VariableDeclaration "ptr"
           Type: uint256
           Source: "uint ptr"
          ElementaryTypeName uint
             Source: "uint"
        FunctionCall
           Type: uint256
           Source: "rfindPtr(self._len, self._ptr, needle._len, needle._ptr)"
          Identifier rfindPtr
             Type: function (uint256,uint256,uint256,uint256) returns (uint256)
             Source: "rfindPtr"
          MemberAccess to member _len
             Type: uint256
             Source: "self._len"
            Identifier self
               Type: struct strings.slice memory
               Source: "self"
          MemberAccess to member _ptr
             Type: uint256
             Source: "self._ptr"
            Identifier self
               Type: struct strings.slice memory
               Source: "self"
          MemberAccess to member _len
             Type: uint256
             Source: "needle._len"
            Identifier needle
               Type: struct strings.slice memory
               Source: "needle"
          MemberAccess to member _ptr
             Type: uint256
             Source: "needle._ptr"
            Identifier needle
               Type: struct strings.slice memory
               Source: "needle"
      ExpressionStatement
         Source: "token._ptr = ptr"
        Assignment using operator =
           Type: uint256
           Source: "token._ptr = ptr"
          MemberAccess to member _ptr
             Type: uint256
             Source: "token._ptr"
            Identifier token
               Type: struct strings.slice memory
               Source: "token"
          Identifier ptr
             Type: uint256
             Source: "ptr"
      ExpressionStatement
         Source: "token._len = self._len - (ptr - self._ptr)"
        Assignment using operator =
           Type: uint256
           Source: "token._len = self._len - (ptr - self._ptr)"
          MemberAccess to member _len
             Type: uint256
             Source: "token._len"
            Identifier token
               Type: struct strings.slice memory
               Source: "token"
          BinaryOperation using operator -
             Type: uint256
             Source: "self._len - (ptr - self._ptr)"
            MemberAccess to member _len
               Type: uint256
               Source: "self._len"
              Identifier self
                 Type: struct strings.slice memory
                 Source: "self"
            TupleExpression
               Type: uint256
               Source: "(ptr - self._ptr)"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "ptr - self._ptr"
                Identifier ptr
                   Type: uint256
                   Source: "ptr"
                MemberAccess to member _ptr
                   Type: uint256
                   Source: "self._ptr"
                  Identifier self
                     Type: struct strings.slice memory
                     Source: "self"
      IfStatement
         Source: "if (ptr == self._ptr) {\n            // Not found\n            self._len = 0;\n        } else {\n            self._len -= token._len + needle._len;\n        }"
        BinaryOperation using operator ==
           Type: bool
           Source: "ptr == self._ptr"
          Identifier ptr
             Type: uint256
             Source: "ptr"
          MemberAccess to member _ptr
             Type: uint256
             Source: "self._ptr"
            Identifier self
               Type: struct strings.slice memory
               Source: "self"
        Block
           Source: "{\n            // Not found\n            self._len = 0;\n        }"
          ExpressionStatement
             Source: "self._len = 0"
            Assignment using operator =
               Type: uint256
               Source: "self._len = 0"
              MemberAccess to member _len
                 Type: uint256
                 Source: "self._len"
                Identifier self
                   Type: struct strings.slice memory
                   Source: "self"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
        Block
           Source: "{\n            self._len -= token._len + needle._len;\n        }"
          ExpressionStatement
             Source: "self._len -= token._len + needle._len"
            Assignment using operator -=
               Type: uint256
               Source: "self._len -= token._len + needle._len"
              MemberAccess to member _len
                 Type: uint256
                 Source: "self._len"
                Identifier self
                   Type: struct strings.slice memory
                   Source: "self"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "token._len + needle._len"
                MemberAccess to member _len
                   Type: uint256
                   Source: "token._len"
                  Identifier token
                     Type: struct strings.slice memory
                     Source: "token"
                MemberAccess to member _len
                   Type: uint256
                   Source: "needle._len"
                  Identifier needle
                     Type: struct strings.slice memory
                     Source: "needle"
      Return
         Source: "return token"
        Identifier token
           Type: struct strings.slice memory
           Source: "token"
  FunctionDefinition "rsplit"
     Source: "function rsplit(slice self, slice needle) internal returns (slice token) {\n        rsplit(self, needle, token);\n    }"
    ParameterList
       Source: "(slice self, slice needle)"
      VariableDeclaration "self"
         Type: struct strings.slice memory
         Source: "slice self"
        UserDefinedTypeName "slice"
           Source: "slice"
      VariableDeclaration "needle"
         Type: struct strings.slice memory
         Source: "slice needle"
        UserDefinedTypeName "slice"
           Source: "slice"
    ParameterList
       Source: "(slice token)"
      VariableDeclaration "token"
         Type: struct strings.slice memory
         Source: "slice token"
        UserDefinedTypeName "slice"
           Source: "slice"
    Block
       Source: "{\n        rsplit(self, needle, token);\n    }"
      ExpressionStatement
         Source: "rsplit(self, needle, token)"
        FunctionCall
           Type: struct strings.slice memory
           Source: "rsplit(self, needle, token)"
          Identifier rsplit
             Type: function (struct strings.slice memory,struct strings.slice memory,struct strings.slice memory) returns (struct strings.slice memory)
             Source: "rsplit"
          Identifier self
             Type: struct strings.slice memory
             Source: "self"
          Identifier needle
             Type: struct strings.slice memory
             Source: "needle"
          Identifier token
             Type: struct strings.slice memory
             Source: "token"
  FunctionDefinition "count"
     Source: "function count(slice self, slice needle) internal returns (uint cnt) {\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\n        while (ptr <= self._ptr + self._len) {\n            cnt++;\n            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\n        }\n    }"
    ParameterList
       Source: "(slice self, slice needle)"
      VariableDeclaration "self"
         Type: struct strings.slice memory
         Source: "slice self"
        UserDefinedTypeName "slice"
           Source: "slice"
      VariableDeclaration "needle"
         Type: struct strings.slice memory
         Source: "slice needle"
        UserDefinedTypeName "slice"
           Source: "slice"
    ParameterList
       Source: "(uint cnt)"
      VariableDeclaration "cnt"
         Type: uint256
         Source: "uint cnt"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\n        while (ptr <= self._ptr + self._len) {\n            cnt++;\n            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\n        }\n    }"
      VariableDeclarationStatement
         Source: "uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len"
        VariableDeclaration "ptr"
           Type: uint256
           Source: "uint ptr"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator +
           Type: uint256
           Source: "findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len"
          FunctionCall
             Type: uint256
             Source: "findPtr(self._len, self._ptr, needle._len, needle._ptr)"
            Identifier findPtr
               Type: function (uint256,uint256,uint256,uint256) returns (uint256)
               Source: "findPtr"
            MemberAccess to member _len
               Type: uint256
               Source: "self._len"
              Identifier self
                 Type: struct strings.slice memory
                 Source: "self"
            MemberAccess to member _ptr
               Type: uint256
               Source: "self._ptr"
              Identifier self
                 Type: struct strings.slice memory
                 Source: "self"
            MemberAccess to member _len
               Type: uint256
               Source: "needle._len"
              Identifier needle
                 Type: struct strings.slice memory
                 Source: "needle"
            MemberAccess to member _ptr
               Type: uint256
               Source: "needle._ptr"
              Identifier needle
                 Type: struct strings.slice memory
                 Source: "needle"
          MemberAccess to member _len
             Type: uint256
             Source: "needle._len"
            Identifier needle
               Type: struct strings.slice memory
               Source: "needle"
      WhileStatement
         Source: "while (ptr <= self._ptr + self._len) {\n            cnt++;\n            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\n        }"
        BinaryOperation using operator <=
           Type: bool
           Source: "ptr <= self._ptr + self._len"
          Identifier ptr
             Type: uint256
             Source: "ptr"
          BinaryOperation using operator +
             Type: uint256
             Source: "self._ptr + self._len"
            MemberAccess to member _ptr
               Type: uint256
               Source: "self._ptr"
              Identifier self
                 Type: struct strings.slice memory
                 Source: "self"
            MemberAccess to member _len
               Type: uint256
               Source: "self._len"
              Identifier self
                 Type: struct strings.slice memory
                 Source: "self"
        Block
           Source: "{\n            cnt++;\n            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\n        }"
          ExpressionStatement
             Source: "cnt++"
            UnaryOperation (postfix) ++
               Type: uint256
               Source: "cnt++"
              Identifier cnt
                 Type: uint256
                 Source: "cnt"
          ExpressionStatement
             Source: "ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len"
            Assignment using operator =
               Type: uint256
               Source: "ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len"
              Identifier ptr
                 Type: uint256
                 Source: "ptr"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len"
                FunctionCall
                   Type: uint256
                   Source: "findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr)"
                  Identifier findPtr
                     Type: function (uint256,uint256,uint256,uint256) returns (uint256)
                     Source: "findPtr"
                  BinaryOperation using operator -
                     Type: uint256
                     Source: "self._len - (ptr - self._ptr)"
                    MemberAccess to member _len
                       Type: uint256
                       Source: "self._len"
                      Identifier self
                         Type: struct strings.slice memory
                         Source: "self"
                    TupleExpression
                       Type: uint256
                       Source: "(ptr - self._ptr)"
                      BinaryOperation using operator -
                         Type: uint256
                         Source: "ptr - self._ptr"
                        Identifier ptr
                           Type: uint256
                           Source: "ptr"
                        MemberAccess to member _ptr
                           Type: uint256
                           Source: "self._ptr"
                          Identifier self
                             Type: struct strings.slice memory
                             Source: "self"
                  Identifier ptr
                     Type: uint256
                     Source: "ptr"
                  MemberAccess to member _len
                     Type: uint256
                     Source: "needle._len"
                    Identifier needle
                       Type: struct strings.slice memory
                       Source: "needle"
                  MemberAccess to member _ptr
                     Type: uint256
                     Source: "needle._ptr"
                    Identifier needle
                       Type: struct strings.slice memory
                       Source: "needle"
                MemberAccess to member _len
                   Type: uint256
                   Source: "needle._len"
                  Identifier needle
                     Type: struct strings.slice memory
                     Source: "needle"
  FunctionDefinition "contains"
     Source: "function contains(slice self, slice needle) internal returns (bool) {\n        return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\n    }"
    ParameterList
       Source: "(slice self, slice needle)"
      VariableDeclaration "self"
         Type: struct strings.slice memory
         Source: "slice self"
        UserDefinedTypeName "slice"
           Source: "slice"
      VariableDeclaration "needle"
         Type: struct strings.slice memory
         Source: "slice needle"
        UserDefinedTypeName "slice"
           Source: "slice"
    ParameterList
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\n        return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\n    }"
      Return
         Source: "return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr"
        BinaryOperation using operator !=
           Type: bool
           Source: "rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr"
          FunctionCall
             Type: uint256
             Source: "rfindPtr(self._len, self._ptr, needle._len, needle._ptr)"
            Identifier rfindPtr
               Type: function (uint256,uint256,uint256,uint256) returns (uint256)
               Source: "rfindPtr"
            MemberAccess to member _len
               Type: uint256
               Source: "self._len"
              Identifier self
                 Type: struct strings.slice memory
                 Source: "self"
            MemberAccess to member _ptr
               Type: uint256
               Source: "self._ptr"
              Identifier self
                 Type: struct strings.slice memory
                 Source: "self"
            MemberAccess to member _len
               Type: uint256
               Source: "needle._len"
              Identifier needle
                 Type: struct strings.slice memory
                 Source: "needle"
            MemberAccess to member _ptr
               Type: uint256
               Source: "needle._ptr"
              Identifier needle
                 Type: struct strings.slice memory
                 Source: "needle"
          MemberAccess to member _ptr
             Type: uint256
             Source: "self._ptr"
            Identifier self
               Type: struct strings.slice memory
               Source: "self"
  FunctionDefinition "concat"
     Source: "function concat(slice self, slice other) internal returns (string) {\n        var ret = new string(self._len + other._len);\n        uint retptr;\n        assembly { retptr := add(ret, 32) }\n        memcpy(retptr, self._ptr, self._len);\n        memcpy(retptr + self._len, other._ptr, other._len);\n        return ret;\n    }"
    ParameterList
       Source: "(slice self, slice other)"
      VariableDeclaration "self"
         Type: struct strings.slice memory
         Source: "slice self"
        UserDefinedTypeName "slice"
           Source: "slice"
      VariableDeclaration "other"
         Type: struct strings.slice memory
         Source: "slice other"
        UserDefinedTypeName "slice"
           Source: "slice"
    ParameterList
       Source: "(string)"
      VariableDeclaration ""
         Type: string memory
         Source: "string"
        ElementaryTypeName string
           Source: "string"
    Block
       Source: "{\n        var ret = new string(self._len + other._len);\n        uint retptr;\n        assembly { retptr := add(ret, 32) }\n        memcpy(retptr, self._ptr, self._len);\n        memcpy(retptr + self._len, other._ptr, other._len);\n        return ret;\n    }"
      VariableDeclarationStatement
         Source: "var ret = new string(self._len + other._len)"
        VariableDeclaration "ret"
           Type: string memory
           Source: "var ret"
        FunctionCall
           Type: string memory
           Source: "new string(self._len + other._len)"
          NewExpression
             Type: function (uint256) pure returns (string memory)
             Source: "new string"
            ElementaryTypeName string
               Source: "string"
          BinaryOperation using operator +
             Type: uint256
             Source: "self._len + other._len"
            MemberAccess to member _len
               Type: uint256
               Source: "self._len"
              Identifier self
                 Type: struct strings.slice memory
                 Source: "self"
            MemberAccess to member _len
               Type: uint256
               Source: "other._len"
              Identifier other
                 Type: struct strings.slice memory
                 Source: "other"
      VariableDeclarationStatement
         Source: "uint retptr"
        VariableDeclaration "retptr"
           Type: uint256
           Source: "uint retptr"
          ElementaryTypeName uint
             Source: "uint"
      InlineAssembly
         Source: "assembly { retptr := add(ret, 32) }\n        memcpy"
      ExpressionStatement
         Source: "memcpy(retptr, self._ptr, self._len)"
        FunctionCall
           Type: tuple()
           Source: "memcpy(retptr, self._ptr, self._len)"
          Identifier memcpy
             Type: function (uint256,uint256,uint256)
             Source: "memcpy"
          Identifier retptr
             Type: uint256
             Source: "retptr"
          MemberAccess to member _ptr
             Type: uint256
             Source: "self._ptr"
            Identifier self
               Type: struct strings.slice memory
               Source: "self"
          MemberAccess to member _len
             Type: uint256
             Source: "self._len"
            Identifier self
               Type: struct strings.slice memory
               Source: "self"
      ExpressionStatement
         Source: "memcpy(retptr + self._len, other._ptr, other._len)"
        FunctionCall
           Type: tuple()
           Source: "memcpy(retptr + self._len, other._ptr, other._len)"
          Identifier memcpy
             Type: function (uint256,uint256,uint256)
             Source: "memcpy"
          BinaryOperation using operator +
             Type: uint256
             Source: "retptr + self._len"
            Identifier retptr
               Type: uint256
               Source: "retptr"
            MemberAccess to member _len
               Type: uint256
               Source: "self._len"
              Identifier self
                 Type: struct strings.slice memory
                 Source: "self"
          MemberAccess to member _ptr
             Type: uint256
             Source: "other._ptr"
            Identifier other
               Type: struct strings.slice memory
               Source: "other"
          MemberAccess to member _len
             Type: uint256
             Source: "other._len"
            Identifier other
               Type: struct strings.slice memory
               Source: "other"
      Return
         Source: "return ret"
        Identifier ret
           Type: string memory
           Source: "ret"
  FunctionDefinition "join"
     Source: "function join(slice self, slice[] parts) internal returns (string) {\n        if (parts.length == 0)\n            return \"\";\n\n        uint length = self._len * (parts.length - 1);\n        for(uint i = 0; i < parts.length; i++)\n            length += parts[i]._len;\n\n        var ret = new string(length);\n        uint retptr;\n        assembly { retptr := add(ret, 32) }\n\n        for(i = 0; i < parts.length; i++) {\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);\n            retptr += parts[i]._len;\n            if (i < parts.length - 1) {\n                memcpy(retptr, self._ptr, self._len);\n                retptr += self._len;\n            }\n        }\n\n        return ret;\n    }"
    ParameterList
       Source: "(slice self, slice[] parts)"
      VariableDeclaration "self"
         Type: struct strings.slice memory
         Source: "slice self"
        UserDefinedTypeName "slice"
           Source: "slice"
      VariableDeclaration "parts"
         Type: struct strings.slice memory[] memory
         Source: "slice[] parts"
        ArrayTypeName
           Source: "slice[]"
          UserDefinedTypeName "slice"
             Source: "slice"
    ParameterList
       Source: "(string)"
      VariableDeclaration ""
         Type: string memory
         Source: "string"
        ElementaryTypeName string
           Source: "string"
    Block
       Source: "{\n        if (parts.length == 0)\n            return \"\";\n\n        uint length = self._len * (parts.length - 1);\n        for(uint i = 0; i < parts.length; i++)\n            length += parts[i]._len;\n\n        var ret = new string(length);\n        uint retptr;\n        assembly { retptr := add(ret, 32) }\n\n        for(i = 0; i < parts.length; i++) {\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);\n            retptr += parts[i]._len;\n            if (i < parts.length - 1) {\n                memcpy(retptr, self._ptr, self._len);\n                retptr += self._len;\n            }\n        }\n\n        return ret;\n    }"
      IfStatement
         Source: "if (parts.length == 0)\n            return \"\""
        BinaryOperation using operator ==
           Type: bool
           Source: "parts.length == 0"
          MemberAccess to member length
             Type: uint256
             Source: "parts.length"
            Identifier parts
               Type: struct strings.slice memory[] memory
               Source: "parts"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Return
           Source: "return \"\""
          Literal, token: [no token] value: 
             Type: literal_string ""
             Source: "\"\""
      VariableDeclarationStatement
         Source: "uint length = self._len * (parts.length - 1)"
        VariableDeclaration "length"
           Type: uint256
           Source: "uint length"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator *
           Type: uint256
           Source: "self._len * (parts.length - 1)"
          MemberAccess to member _len
             Type: uint256
             Source: "self._len"
            Identifier self
               Type: struct strings.slice memory
               Source: "self"
          TupleExpression
             Type: uint256
             Source: "(parts.length - 1)"
            BinaryOperation using operator -
               Type: uint256
               Source: "parts.length - 1"
              MemberAccess to member length
                 Type: uint256
                 Source: "parts.length"
                Identifier parts
                   Type: struct strings.slice memory[] memory
                   Source: "parts"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
      ForStatement
         Source: "for(uint i = 0; i < parts.length; i++)\n            length += parts[i]._len"
        VariableDeclarationStatement
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Source: "i < parts.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "parts.length"
            Identifier parts
               Type: struct strings.slice memory[] memory
               Source: "parts"
        ExpressionStatement
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        ExpressionStatement
           Source: "length += parts[i]._len"
          Assignment using operator +=
             Type: uint256
             Source: "length += parts[i]._len"
            Identifier length
               Type: uint256
               Source: "length"
            MemberAccess to member _len
               Type: uint256
               Source: "parts[i]._len"
              IndexAccess
                 Type: struct strings.slice memory
                 Source: "parts[i]"
                Identifier parts
                   Type: struct strings.slice memory[] memory
                   Source: "parts"
                Identifier i
                   Type: uint256
                   Source: "i"
      VariableDeclarationStatement
         Source: "var ret = new string(length)"
        VariableDeclaration "ret"
           Type: string memory
           Source: "var ret"
        FunctionCall
           Type: string memory
           Source: "new string(length)"
          NewExpression
             Type: function (uint256) pure returns (string memory)
             Source: "new string"
            ElementaryTypeName string
               Source: "string"
          Identifier length
             Type: uint256
             Source: "length"
      VariableDeclarationStatement
         Source: "uint retptr"
        VariableDeclaration "retptr"
           Type: uint256
           Source: "uint retptr"
          ElementaryTypeName uint
             Source: "uint"
      InlineAssembly
         Source: "assembly { retptr := add(ret, 32) }\n\n        for"
      ForStatement
         Source: "for(i = 0; i < parts.length; i++) {\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);\n            retptr += parts[i]._len;\n            if (i < parts.length - 1) {\n                memcpy(retptr, self._ptr, self._len);\n                retptr += self._len;\n            }\n        }"
        ExpressionStatement
           Source: "i = 0"
          Assignment using operator =
             Type: uint256
             Source: "i = 0"
            Identifier i
               Type: uint256
               Source: "i"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        BinaryOperation using operator <
           Type: bool
           Source: "i < parts.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "parts.length"
            Identifier parts
               Type: struct strings.slice memory[] memory
               Source: "parts"
        ExpressionStatement
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);\n            retptr += parts[i]._len;\n            if (i < parts.length - 1) {\n                memcpy(retptr, self._ptr, self._len);\n                retptr += self._len;\n            }\n        }"
          ExpressionStatement
             Source: "memcpy(retptr, parts[i]._ptr, parts[i]._len)"
            FunctionCall
               Type: tuple()
               Source: "memcpy(retptr, parts[i]._ptr, parts[i]._len)"
              Identifier memcpy
                 Type: function (uint256,uint256,uint256)
                 Source: "memcpy"
              Identifier retptr
                 Type: uint256
                 Source: "retptr"
              MemberAccess to member _ptr
                 Type: uint256
                 Source: "parts[i]._ptr"
                IndexAccess
                   Type: struct strings.slice memory
                   Source: "parts[i]"
                  Identifier parts
                     Type: struct strings.slice memory[] memory
                     Source: "parts"
                  Identifier i
                     Type: uint256
                     Source: "i"
              MemberAccess to member _len
                 Type: uint256
                 Source: "parts[i]._len"
                IndexAccess
                   Type: struct strings.slice memory
                   Source: "parts[i]"
                  Identifier parts
                     Type: struct strings.slice memory[] memory
                     Source: "parts"
                  Identifier i
                     Type: uint256
                     Source: "i"
          ExpressionStatement
             Source: "retptr += parts[i]._len"
            Assignment using operator +=
               Type: uint256
               Source: "retptr += parts[i]._len"
              Identifier retptr
                 Type: uint256
                 Source: "retptr"
              MemberAccess to member _len
                 Type: uint256
                 Source: "parts[i]._len"
                IndexAccess
                   Type: struct strings.slice memory
                   Source: "parts[i]"
                  Identifier parts
                     Type: struct strings.slice memory[] memory
                     Source: "parts"
                  Identifier i
                     Type: uint256
                     Source: "i"
          IfStatement
             Source: "if (i < parts.length - 1) {\n                memcpy(retptr, self._ptr, self._len);\n                retptr += self._len;\n            }"
            BinaryOperation using operator <
               Type: bool
               Source: "i < parts.length - 1"
              Identifier i
                 Type: uint256
                 Source: "i"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "parts.length - 1"
                MemberAccess to member length
                   Type: uint256
                   Source: "parts.length"
                  Identifier parts
                     Type: struct strings.slice memory[] memory
                     Source: "parts"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
            Block
               Source: "{\n                memcpy(retptr, self._ptr, self._len);\n                retptr += self._len;\n            }"
              ExpressionStatement
                 Source: "memcpy(retptr, self._ptr, self._len)"
                FunctionCall
                   Type: tuple()
                   Source: "memcpy(retptr, self._ptr, self._len)"
                  Identifier memcpy
                     Type: function (uint256,uint256,uint256)
                     Source: "memcpy"
                  Identifier retptr
                     Type: uint256
                     Source: "retptr"
                  MemberAccess to member _ptr
                     Type: uint256
                     Source: "self._ptr"
                    Identifier self
                       Type: struct strings.slice memory
                       Source: "self"
                  MemberAccess to member _len
                     Type: uint256
                     Source: "self._len"
                    Identifier self
                       Type: struct strings.slice memory
                       Source: "self"
              ExpressionStatement
                 Source: "retptr += self._len"
                Assignment using operator +=
                   Type: uint256
                   Source: "retptr += self._len"
                  Identifier retptr
                     Type: uint256
                     Source: "retptr"
                  MemberAccess to member _len
                     Type: uint256
                     Source: "self._len"
                    Identifier self
                       Type: struct strings.slice memory
                       Source: "self"
      Return
         Source: "return ret"
        Identifier ret
           Type: string memory
           Source: "ret"
